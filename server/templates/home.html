{% extends "layout.html" %}

{% block main %}
 <!-- Removed inline styles -->
 <link rel="stylesheet" href="./static/styles.css">
 <style>
    .footer-container {
        position: relative;
    }
    
    .footer-cta {
        border-bottom: 1px solid #373636;
    }
    
    .single-cta i {
      color: #ff5e14;
      font-size: 30px;
      float: left;
      margin-top: 8px;
    }
    
    .cta-text {
      padding-left: 15px;
      display: inline-block;
    }
    
    .footer-content {
      position: relative;
      z-index: 2;
    }
    
    .footer-pattern img {
      position: absolute;
      top: 0;
      left: 0;
      height: 330px;
      background-size: cover;
      background-position: 100% 100%;
    }
    
    .footer-logo {
      margin-bottom: 30px;
    }
    .footer-logo img {
        max-width: 200px;
    }
    
    .footer-text p {
      margin-bottom: 14px;
      font-size: 14px;
      line-height: 28px;
    }
    
    
    .footer-widget-heading h3 {
           font-size: 20px;
           font-weight: 600;
           margin-bottom: 0px;
           position: relative;
    }
    
    .footer-widget-heading h3::before {
        content: "";
        position: absolute;
        left: 0;
        bottom: -15px;
        height: 2px;
        width: 50px;
        background-color:var(--orange);
    }
    
    .footer-widget ul{
        margin: 0px;
        padding: 0px;
    
    }
    
    
    .footer-widget ul li {
        display: inline-block;
        width: auto;
        margin-right: 12px;
        margin-bottom: 0;
        float: none;
    }
    
    .footer-widget ul li a {
        color: #878787;
        text-transform: capitalize;
    }
    
    .footer-widget ul li a:hover {
        color: var(--orange);
    }

    .video-section {
        display: grid;
        grid-template-columns:1fr;
        grid-template-rows: auto auto;
        margin: 0 auto;
        padding: 0; 
        background-color: rgba(0, 0, 0, 0.1);
        border-radius: 5px;
        width:40%;
        position: relative;
        text-align: center;
    }
    
    .video-frame {
        position: relative;
        background-color: transparent;
        overflow: visible; 
        z-index: 10;
    }
    
    .video-container {
        position: relative;
        left: 0;
        margin:0 auto;
        display: grid;
        grid-template-rows: 1fr;
        width: 100%;
        border-radius: 6px;
        box-shadow: 4px 4px 25px -2px rgba(0, 0, 0, 0.3);
    }

    .video-content {
        position:relative;
        width:100%;
        padding: 0; 
        margin: 0; 
        height: auto;
    }
    
    #video {
        display: block; 
        width: 100%; 
        aspect-ratio: 16/9;
        border: none;
    }
    
    .video__info {
        padding: 0.1em 0;
        height: auto;
    }
    
    .video_word {
        margin: 0.5em 0;
        color: black;
        font-size: 1em;
        text-align: center; 
        width: 100%;
    }
    
    .video_word span {
        padding-left: 0.15em;
        font-size: 1em;
        word-wrap: break-word; 
    }
    

   </style>

 <body>

    <div class="home-container">
       <div class="title-container">
           <div class="entry-title">Maximize the impact of your canvassing and donations</div>
           <hr>
           <div class="main-title">Vote Maximizer</div>
           <div class="sub-title">Click on a state for more information</div>
       </div>
       <div class="map-container">
           <div class="col" id="map"></div>
       </div>


     <div class="legend-container">
        <fieldset>
            <form action="/local" method="post">
                <div class="input-group">
                    <label for="location">Find pivotal elections near you:</label>

                    <div class="search-container">
                            <input type="text" class="form-control" id="location" name="location" placeholder="Type address/ZIP">
                            <button class="search-button">Search</button>
                        
                    </div>
                    
                </div>  
            </form>

            <div id="legend-section" class="legend-section">
                <div id="legend-box">
                    <div class="legend-items"> 
                        <button class="legend-btn" data-level="democracy" style="background-color: #9277DE;">
                            Democracy repair
                        </button>
                    </div>
                    <div class="legend-items">
                        <button class="legend-btn" data-level="presidential" style="background-color: #F5928D;">
                            President
                        </button>
                    </div>
                    <div class="legend-items">
                        <button class="legend-btn" data-level="senate" style="background-color: #fec548;">
                            Senate
                        </button>
                    </div> 
                    <div class="legend-items">
                        <button class="legend-btn" data-level="house" style="background-color: #B4CDE3;">
                            House
                        </button>
                    </div>  
                    <div class="legend-items">
                        <button class="legend-btn" data-level="statewide" style="background-color: #D19E9B;">
                            State
                        </button>
                    </div>
                    <div class="legend-items">
                        <button class="legend-btn" data-level="abortion" style="background-color: #F768A0;">
                            Abortion
                        </button>
                    </div>
                    <div class="legend-items">
                        <button class="legend-btn" data-level="ballot_all" style="background-color: #13DDB7;">
                            Ballot Measures
                        </button>
                    </div>
                </div>
            </div>
        </fieldset>
    </div>
    
    <div class="video-wrapper">
        <section class="video-section">
            <div class="video-frame">
                <div class="video-container">
                    <div class="video-content" id="video-content" style="flex: 1;">
                        <iframe id="video" src="https://www.youtube.com/embed/bSJEDoHk4-c?start=4" frameborder="0" allowfullscreen></iframe>
                    </div>
                </div>
            </div>

            <div class="video__info">
                <div class="video_word">
                    <span>A quick tour of vote maximizer</span>
                </div>
            </div>
        </section>
    </div>
    <div class="blog-wrapper">
        <div class="blog-container">
            <div class="title-line-wrapper">
                <hr class="title-line">
                <h1>What's new?</h1>
                <hr class="title-line">
            </div>
            
          <div class="cards-wrapper" id="cards">
            <a href="https://samwang.substack.com/p/nebraska-rising" target="_blank" style="text-decoration: none;">
              <card>
                <div  class="card-date">Oct 6 2024</div>
                <span class="card-title">
                    Nebraska Rising
                </span>
                <span class="card-content">
                    The biggest bargain of the 2024 election, for the cost of a few runzas.
                   
                </span>

                <div class="card-footer">
                   
                </div>
            </card>
            </a>

            <a href="https://samwang.substack.com/p/jersey-strong" target="_blank" style="text-decoration: none;">
                <card>
                    <div  class="card-date">Oct 5 2024</div>
                    <span class="card-title">
                        Jersey Strong
                    </span>
                    <span class="card-content">
                        Feeling powerless in New Jersey this year? Vote Maximizer has something for you.
                    </span>
                    <div class="card-footer">

                    </div>
                </card>
            </a>

            <card>
                <div  class="card-date">Sep 17 2024</div>
                <span class="card-title">
                    New from the great people at Bolts Magazine
                </span>
                <span class="card-content">
                A deep-dive analysis of all 
                <a href="https://boltsmag.org/elections-chief-elections-2024-guide/"
                target="_blank">12 states where the chief election official is up for election </a> this November.

                </span>

                <div class="card-footer">
                   
                </div>
            </card>

            <card>
                <div  class="card-date">Sep 10 2024</div>
                <span class="card-title">
                    Welcome to the new release of Vote Maximizer!
                </span>
                <span class="card-content">
                    Learn how it helps maximize your activism 
                    <a href="https://samwang.substack.com/p/a-voter-centered-approach-to-optimizing" target="_blank">here</a>. Then watch
                    Founder Sam Wang's <a href="https://www.ted.com/speakers/sam_wang" target="_blank">TED Talk</a>, on how all voters can be represented.
                </span>

                <div class="card-footer">
                   
                </div>
            </card>
        </div>
        </div>
        </div> 
    </div>
        <br>

<script type="module">    
    const state_to_number = {{ state_to_number | tojson }};
    const number_to_state = Object.fromEntries(
        Object.entries(state_to_number).map(([state, number]) => [number, state])
    );
    const states = Object.keys(state_to_number);
    const postal_codes = JSON.parse('{{ postal_codes | tojson }}');
    import voterEmpowerment from './static/js/voter_empowerment.js';

    // Use the pre-filtered data directly
    const democracyData = {{ democracy_data | tojson | safe }};
    const abortionData = {{ abortion_data | tojson | safe }};
    const houseData = {{ house_data | tojson | safe }};
    const indexedHouseData = indexVoterData(houseData);
    const senateData = {{ senate_data | tojson | safe }};
    const presidentData = {{ president_data | tojson | safe }};
    
    const governorData = {{ governor_data | tojson | safe }};
    const stateLegUpperData = {{ state_leg_upper_data | tojson | safe }};
    const stateLegLowerData = {{ state_leg_lower_data | tojson | safe }};
    // Combine state-level
    const stateData = [...governorData, ...stateLegUpperData, ...stateLegLowerData];
    // Combine all ballot data 
    const ballotData = [...democracyData, ...abortionData];
    const startingData = null;
    const LEVELS = ['democracy', 'presidential', 'senate', 'house', 'statewide', 'abortion', 'ballot_all']
    let animationRunning = true;

    import * as colors from './static/js/colors.js';
    console.log("Imported colors:", colors);
    //import * from './static/js/colors.js';
    console.log("color.COLOR_BG", colors.COLOR_BG);
    console.log("BG:", COLOR_BG);
 
        // Set the background color of the body
        document.body.style.backgroundColor = colors.COLOR_BG;
        mapboxgl.accessToken = '{{ mapbox_key }}';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mikeklein1/cm0h4ib4o01mf01qv90n802b8',
            zoom: 3.5, // Adjust as needed
            maxZoom: 6,
            minZoom: 2,
            center: [0,-2],
            projection: 'mercator', // Using an equal-area projection,
            background: colors.COLOR_BG  // Use the same color for the map background
        });

        // Disable map rotation
        map.dragRotate.disable();
        map.touchZoomRotate.disableRotation
        map.dragPan.enable()
        map.pitchWithRotate = false
        map.scrollZoom.disable();

        // Function to interpolate between two colors
        function interpolateColor(color1, color2, factor) {
            const result = color1.slice();
            for (let i = 0; i < 3; i++) {
                result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
            }
            return result;
        }
        // Function to convert hex to RGB
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }
        // Function to convert RGB to hex
        function rgbToHex(rgb) {
            return "#" + rgb.map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }).join('');
        }

      

    // Create this function to index the voter data
    function indexVoterData(voterData) {
        return voterData.reduce((acc, item) => {
            const key = `${item.state}${item.congress}`;
            if (!acc[key] || parseFloat(item.voter_power) > parseFloat(acc[key].voter_power)) {
                acc[key] = item;
                }
                return acc;
            }, {});
        }   

    //add all the layers as const herep
    /* const layers = {

        starting: 'static/data/calculated_files/geojsons/president_albers.geojson',
        abortion: 'static/data/geojson_imports/geojson_final/ballot_abort_albers.geojson',
        democracy: 'static/data/geojson_imports/geojson_final/ballot_VPM_albers.geojson',
        //aggregate: 'static/data/calculated_files/geojsons/aggregate_albers.geojson',
        presidential: 'static/data/calculated_files/geojsons/president_albers.geojson',
        senate: 'static/data/calculated_files/geojsons/senate_albers.geojson',
        house: 'static/data/geojson_imports/geojson_final/house_albers.geojson',
        statewide: 'static/data/calculated_files/geojsons/governor_albers.geojson',
        ballot_all: 'static/data/geojson_imports/geojson_final/ballot_initiatives_main_albers.geojson',
        //state_leg_up:'static/data/geojson_imports/geojson_final/state_leg_upper_albers.geojson',
        //state_leg_low:'static/data/geojson_imports/geojson_final/state_leg_lower_albers.geojson'        
    }; */
    const layers = {
        baseStatesMap: 'static/data/calculated_files/geojsons/president_albers.geojson',
        houseMap: 'static/data/calculated_files/geojsons/congress_house_albers.geojson',
        //houseMap: 'static/data/geojson_imports/geojson_final/house_albers.geojson',
        stateUpperMap: 'static/data/calculated_files/geojsons/state_upper_legislature_albers.geojson',
        stateLowerMap: 'static/data/calculated_files/geojsons/state_lower_legislature_albers.geojson',
    };
    let currentLayerId = 'starting'; // adjust the layer that pops up first here

    function generateGenericPopupContent(feature, config, layerId) {
        let stateName = feature.properties['NAME'] || feature.properties['state_name']
        let districtNumber; 
        let entityType = 'State';
        if (['house', 'state_leg_up', 'state_leg_low'].includes(layerId))
        {
            const stateFP = feature.properties.state || feature.properties.STATEFP;
            console.log("stateFP:", stateFP);
            stateName = number_to_state[stateFP];
            console.log("stateName:", stateName);
            districtNumber = feature.properties.NAMELSAD;
            console.log("districtNumber:", districtNumber);
            stateName = `${stateName} ${districtNumber}`;
            console.log("stateName:", stateName);
            entityType = 'District';
        }
        
        let content = `<div class="custom-popup"><strong>${entityType}:</strong> ${stateName}<br>`;
        
        if (config.popupContentGenerator) {
            content += config.popupContentGenerator(feature, config.jsonData, stateName);
        } else {
            content += `<strong>No specific data available.</strong>`;
        }
        ;
        return content;
    }
    
    function startingPopupContent(feature, jsonData, stateName) {
        return `<br>Click for more details.</div>`;
    }

    function ballotPopupContent(feature, jsonData, stateName) {
        const initiatives = jsonData.filter(initiative => initiative.state_name === stateName);
        return initiatives.length > 0 
            ? `<strong>Total initiatives:</strong> ${initiatives.length}
            <br>Click for more details.</div>`
            : `There are no ballot initiatives in this state.`;
    }

    function abortionPopupContent(feature, jsonData, stateName) {
        const initiatives = jsonData.filter(initiative => initiative.state_name === stateName);
        return initiatives.length > 0 
            ? `<strong>${stateName} has reproductive rights on the ballot!</strong>
            <br>Click for more details.</div>`
            : `There are no reproductive rights initiatives in this state.`;
    }
    
    function competitiveRacePopupContent(feature, jsonData, stateName) {
        const races = jsonData.filter(race => race.state_name === stateName);
        const maxVoterPower = Math.max(...races.map(race => parseInt(race.voter_power) || 0));
        return maxVoterPower > 0
            ? `<strong>Maximum Voter Power:</strong> ${maxVoterPower}
            <br>Click for more details.</div>`
            : `No competitive races.`;
    }
    
    function housePopupContent(feature, jsonData, stateName) {

        //First get stateFP from feature
        const stateFP = feature.properties.state || feature.properties.STATEFP;
        //now look upu the state name for this number
        const newStateName = number_to_state[stateFP];
        const districtNumber = feature.properties.NAMELSAD;

        const congressValue = feature.properties.congress;
        const matchingData = jsonData[`${stateFP}${congressValue}`];

        const voterPower = matchingData ? parseInt(matchingData.voter_power) || 0 : 0;
        return voterPower > 0
            ? `<strong>Voter Power:</strong> ${voterPower}
            <br>Click for more details.</div>`
            : `No competitive race in this district.`;
    }

    //Layer configuration map, simplifies logic for each layer.
    const layerConfig = {
        'starting': {
            colorScale: colors.COLOR_DEMOCRACY,
            baseMap: 'baseStatesMap',
            jsonData: democracyData,
            idProperty: 'STATEFP',
            borderColor: colors.COLOR_BORDER,
            borderWidth: 1.5,
            popupContentGenerator: startingPopupContent
        },
        'presidential': {
            colorScale: colors.presidentScale,
            baseMap: 'baseStatesMap',
            jsonData: presidentData,
            idProperty: 'STATEFP',
            matchingFunction: (feature, dataItem) => feature.properties.state_name === dataItem.state_name,
            borderColor: colors.COLOR_BORDER,
            borderWidth: 1.5,
            popupContentGenerator: competitiveRacePopupContent
        },
        'senate': {
            colorScale: colors.senateScale,
            baseMap: 'baseStatesMap',
            jsonData: senateData,
            idProperty: 'STATEFP',
            matchingFunction: (feature, dataItem) => feature.properties.state_name === dataItem.state_name,
            borderColor: colors.COLOR_BORDER,
            borderWidth: 1.5,
            popupContentGenerator: competitiveRacePopupContent
        },
        'statewide': {
            colorScale: colors.stateLegScale,
            baseMap: 'baseStatesMap',
            jsonData: stateData,
            idProperty: 'STATEFP',
            matchingFunction: (feature, dataItem) => feature.properties.state_name === dataItem.state_name,
            borderColor: colors.COLOR_BORDER,
            borderWidth: 1.5,
            popupContentGenerator: competitiveRacePopupContent
        },
        'house': {
            colorScale: colors.houseScale,
            baseMap: 'houseMap',
            jsonData: indexedHouseData,
            idProperty: 'GEOID',
            matchingFunction: (feature, dataItem) => {
                console.log("feature:", feature.properties);
                console.log(feature.properties.GEOID);
                const key = feature.properties.GEOID;
                return indexedHouseData.hasOwnProperty(key);
            },
            borderColor: colors.COLOR_BORDER,
            borderWidth: 0.5,
            popupContentGenerator: housePopupContent
        },
        'state_leg_up': {
            colorScale: colors.stateLegScale,
            baseMap: 'stateUpperMap',
            jsonData: stateLegUpperData,
            idProperty: 'GEOIDFQ',
            borderColor: colors.COLOR_BORDER_LEG,
            borderWidth: 0.5,
        },
        'state_leg_low': {
            colorScale: colors.stateLegScale,
            baseMap: 'stateLowerMap',
            jsonData: stateLegLowerData,
            idProperty: 'GEOIDFQ',
            borderColor: colors.COLOR_BORDER_LEG,
            borderWidth: 0.5,
        },
        'ballot_all': {
            colorScale: colors.COLOR_KEY_BALLOT,
            baseMap: 'baseStatesMap',
            jsonData: ballotData,
            idProperty: 'STATEFP',
            borderColor: colors.COLOR_BORDER,
            borderWidth: 1.5,
            popupContentGenerator: ballotPopupContent   
        },
        'democracy': {
            colorScale: colors.COLOR_DEMOCRACY,
            baseMap: 'baseStatesMap',
            jsonData: democracyData,
            idProperty: 'STATEFP',
            borderColor: colors.COLOR_BORDER,
            borderWidth: 1.5,
            popupContentGenerator: ballotPopupContent
        },
        'abortion': {
            colorScale: colors.COLOR_ABORTION,
            baseMap: 'baseStatesMap',
            jsonData: abortionData,
            idProperty: 'STATEFP',
            borderColor: colors.COLOR_BORDER,
            borderWidth: 1.5,
            popupContentGenerator: abortionPopupContent
        }
    };
    const geoJsonCache = {};

    console.log("layerConfig:", layerConfig);
    async function loadGeoJson(layerId) {
        console.log("Loading GeoJSON for", layerId);
        if (geoJsonCache[layerId]) {
            return geoJsonCache[layerId];
        }

        const maxRetries = 10;
        const baseDelay = 1000; // 1 second

        for (let attempt = 0; attempt < maxRetries; attempt++) {
            const startTime = performance.now();
            try {
                const response = await fetch(layers[layerId]);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                geoJsonCache[layerId] = data;
                
                const endTime = performance.now();
                const downloadTime = (endTime - startTime) / 1000; // Convert to seconds
                console.log(`GeoJSON for ${layerId} loaded in ${downloadTime.toFixed(2)} seconds`);
                
                return data;
            } catch (error) {
                console.error(`Attempt ${attempt + 1} failed to load ${layerId}:`, error);
                
                if (attempt === maxRetries - 1) {
                    console.error(`Failed to load ${layerId} after ${maxRetries} attempts`);
                    throw error;
                }

                // Exponential backoff
                const delay = baseDelay * Math.pow(2, attempt);
                console.log(`Retrying in ${delay / 1000} seconds...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

        // Load baseStatesMap first
        const baseStatesMapPromise = loadGeoJson('baseStatesMap');

        async function lazyLoadOtherLayers() {
            const otherLayers = Object.keys(layers).filter(layer => layer !== 'baseStatesMap');
            for (const layer of otherLayers) {
                loadGeoJson(layer).catch(error => console.error(`Error lazy loading ${layer}:`, error));
            }
        }

        async function addGeoJsonLayer(layerId) {
            const config = layerConfig[layerId];
            const idProperty = config.idProperty;
            console.log("Adding layer:", layerId);
            if (map.getSource(currentLayerId)) {
                map.removeLayer(currentLayerId + '-fill');
                map.removeLayer(currentLayerId + '-line');
                map.removeLayer(currentLayerId + '-hover-line');
                map.removeSource(currentLayerId);
            }

            if (!geoJsonCache[config.baseMap]) {
                await loadGeoJson(config.baseMap);
            }

            map.addSource(layerId, {
                type: 'geojson',
                data: geoJsonCache[config.baseMap],
                promoteId: idProperty
            });
            console.log("layerId:", layerId);
            console.log("createFillPaint(layerId, config):", createFillPaint(layerId, config));
            map.addLayer({
                id: layerId + '-fill',
                type: 'fill',
                source: layerId,
                paint: {
                    'fill-color': createFillPaint(layerId, config),
                    'fill-opacity': 1
                }
            }, 'albersusa-points');

            map.addLayer({
                id: layerId + '-line',
                type: 'line',
                source: layerId,
                paint: {
                    'line-color': config.borderColor || colors.COLOR_BORDER,
                    'line-width': config.borderWidth || 1.5,
                    'line-opacity': 1
                }
            }, 'albersusa-points');

            map.addLayer({
                id: layerId + '-hover-line',
                type: 'line',
                source: layerId,
                paint: {
                    'line-color': ['case', 
                        ['boolean', ['feature-state', 'hover'], false], 
                        colors.COLOR_HOVER, 
                        config.borderColor || colors.COLOR_BORDER
                    ],
                    'line-color-transition': { duration: 1000 },
                    'line-width': ['case', 
                        ['boolean', ['feature-state', 'hover'], false], 
                        4, 
                        config.borderWidth || 1.5
                    ],
                    'line-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0],
                }
            });

            map.moveLayer(layerId + '-hover-line');
            currentLayerId = layerId;
        }

        let hoveredStateId = null; // This will hold the ID of the feature under the mouse.


        const popup = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false
        });


    function createFillPaint(layerId, config) {
        if (Array.isArray(config.colorScale) && typeof config.matchingFunction === 'function') {
            // Step 1: Group by feature properties and find max voter power
            const stateMaxPower = {};
            for (const key in config.jsonData) {
                const item = config.jsonData[key];
                const stateKey = config.idProperty === 'GEOID' ?
                    `${item.state}${item.congress}` :
                    item.state;
                const power = Math.round(parseFloat(item.voter_power) || 0);
                
                if (!isNaN(power)) {
                    stateMaxPower[stateKey] = Math.max(stateMaxPower[stateKey] || 0, power);
                }
            }

            // Step 2: Convert to array for Mapbox expression
            const voterPowerData = Object.entries(stateMaxPower).flatMap(([name, power]) => [name, power]);

            // Step 3: Return the fill paint expression
            const fillPaint = [
                'interpolate',
                ['linear'],
                ['coalesce',
                    ['match', ['get', config.idProperty],
                        ...voterPowerData,
                        0 // Default value if idProperty is not found in the match
                    ],
                    0
                ],
                0, config.colorScale[0],
                20, config.colorScale[1],
                40, config.colorScale[2],
                60, config.colorScale[3],
                80, config.colorScale[4]
            ];
                    return fillPaint;
        } else {
            // Handle the case where colorScale is a single color
            const colorData = [];
            for (const key in config.jsonData) {
                const item = config.jsonData[key];
                const name = item.state_name || item.NAME;
                if (name && !colorData.includes(name)) {
                    colorData.push(name, config.colorScale);
                }
            }
            return [
                'match',
                ['get', 'NAME'],
                ...colorData,
                colors.COLOR_DEFAULT
            ];
        }
    }

    map.on('click', function (e) {
        const features = map.queryRenderedFeatures(e.point);
        let layerId = currentLayerId;
        if (!features || !features.length) {
            return;
        }
        let feature = map.queryRenderedFeatures(e.point, { layers: [layerId + '-fill'] })[0];
        let location;
        let selection = '';
        if (feature) {
            selection = getHighlightedButton();
            location = feature.properties.STUSPS || feature.properties.state_name;
            if (location && (states.includes(location) || postal_codes.includes(location))) {
                window.location.href = `/state?location=${location}&selection=${selection}`;
                return;
            }
        }
        if (!location) {
            console.log('no location');
            feature = map.queryRenderedFeatures(e.point, { layers: ['albersusa'] })[0];
            location = feature.properties.STUSPS || feature.properties.state_name;
            if (location && states.includes(location)) {
                window.location.href = `/state?location=${location}`;
                return;
            }
        }
    });

    // mouse event for hovering
    map.on('mousemove', function (e) {

        let layerId = currentLayerId;
        let features = map.queryRenderedFeatures(e.point, { layers: [layerId + '-fill'] });
        if (features && features.length > 0) {
            const feature = features[0];
            const config = layerConfig[layerId];
            const currentId = layerId;


            // Handle hover state
            if (hoveredStateId !== layerId) {
                if (hoveredStateId) {
                    map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: false });
                }
                hoveredStateId = currentId;
                map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: true });
            }

            // Generate popup content
            let stateName = feature.properties['NAME'] || feature.properties['state_name'];
            if (!stateName) {
                const stateNumber = feature.properties['STATEFP'];
                stateName = states[stateNumber];
            }

            const popupContent = generateGenericPopupContent(feature, config, layerId);

            // Display popup
            popup.setLngLat(e.lngLat).setHTML(popupContent).addTo(map);
            map.getCanvas().style.cursor = 'pointer';
        } else {
            // Reset hover state and remove popup when not over a feature
            if (hoveredStateId) {
                map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: false });
                hoveredStateId = null;
            }
            map.getCanvas().style.cursor = '';
            popup.remove();
        }
    });

    map.on('mouseleave', function () {
        let layerId = currentLayerId;
        if (hoveredStateId) {
            map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: false });
            hoveredStateId = null;
        }
        map.getCanvas().style.cursor = '';
        popup.remove();
    });



    map.on('load', async function () {
        try {
            const mapDiv = document.getElementById('map'); 
            const width = mapDiv.offsetWidth;
            const height = mapDiv.offsetHeight;

            function fitMapToContainer() {
                const width = mapDiv.offsetWidth;
                const height = mapDiv.offsetHeight;
                
                const aspectRatio = width / height;
                let bound_value;
                let bounds;

                if (aspectRatio >= 1) {
                    // Landscape mode
                    bound_value = 15 * Math.max(1, aspectRatio);
                    bounds = [[-bound_value, -bound_value / aspectRatio], [bound_value, bound_value / aspectRatio]];
                } else {
                    // Portrait mode
                    bound_value = 15 / Math.min(1, aspectRatio);
                    bounds = [[-bound_value * aspectRatio, -bound_value], [bound_value * aspectRatio, bound_value]];
                }
                
                map.fitBounds(bounds, { 
                    padding: {top: 0, bottom: 0, left: 50, right: 50}, 
                    animate: false 
                });
            }

            fitMapToContainer();
            window.addEventListener('resize', fitMapToContainer);

            console.log("Loading base states map...");
            const baseStatesMapData = await baseStatesMapPromise;
            console.log("Base states map loaded:", baseStatesMapData);

            if (baseStatesMapData) {
                console.log("Adding starting layer");
                await addGeoJsonLayer('starting');
                console.log("Starting layer added");

                lazyLoadOtherLayers();
            } else {
                console.error("Failed to load base states map data");
            }
        } catch (error) {
            console.error('Error during initial map setup:', error);
        }
    });

    // Set initial color for all states
    //map.setPaintProperty('starting-fill', 'fill-color', colors.COLOR_DEFAULT);

        // Wait for the source to load
        map.once('idle', function() {   
            const DEBUG_DISABLE_ANIMATION = false;
            if (DEBUG_DISABLE_ANIMATION) {
                animationRunning = false;
            }
            let animationId;
            let features = [];
            let allFeatures = [];
            let powerLevels = LEVELS;
            let currentPowerLevelIndex = 0;
            let skipFadeFirst = true;
            let fadeInDelay = 1500;
            const nextGroupDelay = 2000; // Increased delay between power levels
            const fadeOutDelay = 1500;
            const steps = 30;
            const stateColors = new Map();
            const stateOpacities = new Map();

        function queryFeatures() {
            allFeatures= map.queryRenderedFeatures({ layers: ['starting-fill'] });
            
            features = allFeatures.filter((feature, index, self) =>
                index === self.findIndex((t) => (
                    t.properties.STATEFP === feature.properties.STATEFP
                )) && feature.properties.power_level !== "none"
            );

            if (features.length > 0) {
                animateNextPowerLevel();
            } else {
                console.error("No features found. Retrying in 1 second...");
                setTimeout(queryFeatures, 1000);
            }
        }
        queryFeatures();

        async function animateNextPowerLevel() {
            if (!features || features.length === 0) {
                console.error("Features not loaded yet. Retrying in 1 second...");
                setTimeout(animateNextPowerLevel, 1000);
                return;
            }
            if (skipFadeFirst) {
                fadeInDelay = 0;
                skipFadeFirst = false;
            }
            else {
                fadeInDelay = 1500;
            }

                if (currentPowerLevelIndex >= powerLevels.length) {
                    currentPowerLevelIndex = 0;
                } 
                    const currentPowerLevel = powerLevels[currentPowerLevelIndex];
                    
                    let statesToAnimate = features.filter(feature => 
                        voterEmpowerment[currentPowerLevel].includes(feature.properties.STUSPS) || 
                        voterEmpowerment[currentPowerLevel].includes(feature.properties.state_abbrev)
                    );
                    const targetColor = getColorForPowerLevel(currentPowerLevel);
                    // Set all states to default fill-color
                    allFeatures.forEach(feature => {
                        const stateId = feature.properties.STATEFP;
                        stateColors.set(stateId, colors.COLOR_DEFAULT);
                        stateOpacities.set(stateId, 1); 
                    });
                    updateMapColors();


                // Get the button with the data-level matching currentPowerLevel and add "highlight" class
                const currentButton = document.querySelector(`.legend-btn[data-level="${currentPowerLevel}"]`);
                if (currentButton) {
                    currentButton.classList.add('highlight');
                   
                }

                // Remove "highlight" class from other buttons
                document.querySelectorAll('.legend-btn').forEach(button => {
                    if (button !== currentButton) {
                        button.classList.remove('highlight');
                    }
                });
                await animateStates(statesToAnimate, targetColor, true);
                currentPowerLevelIndex++;
                // Use Promise-based setTimeout
                await new Promise(resolve => setTimeout(resolve, nextGroupDelay));
                await fadeOutStates(statesToAnimate);
                if (animationRunning) { 
                    animateNextPowerLevel(); // Continue to next power level
                }

        }

        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        }

        function animateStates(states, targetColor,useLinearFade = false) {
            return new Promise((resolve) => {
                const opacityDelay = fadeInDelay / steps;
                
                states.forEach(feature => {
                    const stateId = feature.properties.STATEFP;
                    stateColors.set(stateId, targetColor);
                });
                
                for (let i = 0; i <= steps; i++) {
                    setTimeout(() => {
                        //adding one prevents ever being 0
                        const t = (i + 1) / (steps + 1);
                        const opacity = useLinearFade ? t : easeInOutQuad(t);
                        states.forEach(feature => {
                            const stateId = feature.properties.STATEFP;
                            stateOpacities.set(stateId, opacity);
                        });
                        updateMapColors();
                        if (i === steps) resolve(); // Resolve the promise when animation is complete
                    }, i * opacityDelay);
                }
            });
        }

        function fadeOutStates(states) {
            return new Promise((resolve) => {
                const opacityDelay = fadeOutDelay / steps;
                
                for (let i = steps; i >= 0; i--) {
                    setTimeout(() => {
                        const t = i / steps;
                        const opacity = easeInOutQuad(t);
                        states.forEach(feature => {
                            const stateId = feature.properties.STATEFP;
                            stateOpacities.set(stateId, opacity);
                        });
                        updateMapColors();
                        if (i === 0) {
                            states.forEach(feature => {
                                const stateId = feature.properties.STATEFP;
                                stateColors.set(stateId, colors.COLOR_DEFAULT);
                            });
                            updateMapColors();
                            resolve();
                        }
                    }, (steps - i) * opacityDelay);
                }
            });
        }

        function updateMapColors() {
            const colorExpression = [
                'match',
                ['get', 'STATEFP'],
                ...Array.from(stateColors).flatMap(([statefp, color]) => [statefp, color]),
                colors.COLOR_DEFAULT
            ];

            const opacityExpression = [
                'match',
                ['get', 'STATEFP'],
                ...Array.from(stateOpacities).flatMap(([statefp, opacity]) => [statefp, opacity]),
                0.1 // Default opacity for states not yet animated
            ];


            if (map.getLayer('starting-fill')) {
                map.setPaintProperty('starting-fill', 'fill-color', colorExpression);
                map.setPaintProperty('starting-fill', 'fill-opacity', opacityExpression);
            } 
        }

        function stopAnimation() {
            if (animationId) {
                clearTimeout(animationId);
            }
        }
    });

function getColorForPowerLevel(powerLevel) {
    switch(powerLevel) {
        case 'democracy': return colors.COLOR_DEMOCRACY;
        case 'presidential': return colors.COLOR_PRESIDENT;
        case 'senate': return colors.COLOR_SENATE;
        case 'house': return colors.COLOR_HOUSE;
        case 'governor': return colors.COLOR_GOVERNOR;
        case 'abortion': return colors.COLOR_ABORTION;
        case 'ballot_all': return colors.COLOR_KEY_BALLOT;
        case 'statewide': return colors.COLOR_STATE_LEGISLATURE;
        default: return colors.COLOR_DEFAULT;
    }
}

document.querySelectorAll('.legend-btn').forEach(button => {
    const originalColor = window.getComputedStyle(button).backgroundColor;
    button.style.setProperty('--btn-bg-color', originalColor); 
    
    button.addEventListener('mouseover', () => {
        button.style.setProperty('--btn-bg-color', originalColor);
    });

    button.addEventListener('focus', () => {
        button.style.setProperty('--btn-bg-color', originalColor);
    });

    
    button.addEventListener('click', () => {
        button.classList.toggle('highlight'); 
    });
});

// Write a function that searches all legend buttons and 
// returns the one that is clicked
function getClickedButton() {
    return document.querySelector('.legend-btn.active');
}
// Return the data-level of the highlighted class
function getHighlightedButton() {
    const highlightedButton = document.querySelector('.legend-btn.highlight');
    return highlightedButton.getAttribute('data-level');
}

// Add click event listener for legend buttons
document.querySelectorAll('.legend-btn').forEach(button => {
 
    button.addEventListener('click', async function() {


        //stop the animation
        animationRunning = false;
        const powerLevel = this.getAttribute('data-level');
        const color = getColorForPowerLevel(powerLevel);
        

        
        // Remove active class from all buttons
        document.querySelectorAll('.legend-btn').forEach(btn => {
            const btnOriginalColor = btn.style.backgroundColor; 
            btn.classList.remove('active');
            btn.classList.remove('highlight');

        });
        
        // Add active class to clicked button
        this.classList.add('active');
        this.classList.add('highlight');

        
        // Filter the map to show only states with the selected power level
        // Change the layer to the one that is clicked
        await addGeoJsonLayer(powerLevel);
    });
});

document.getElementById('location').addEventListener('keypress', function (e) {
    if (e.key === 'Enter') {
        e.preventDefault(); // Prevent the default action (form submission)
        e.target.form.submit(); // Submit the form
    }
});

//Clean input after left page
window.addEventListener('pageshow', function(event) {
    if (event.persisted) {  
        document.getElementById('location').value = '';
    }
});

    </script>
</body>
{% endblock %}