{% extends "layout.html" %}

{% block main %}
 <!-- Removed inline styles -->
 <link rel="stylesheet" href="./static/styles.css">
 <body>

    <div class="home-container">
       <div class="title-container">
           <div class="entry-title">Maximize your individual voter power and strengthen democracy in 2024</div>
           <hr>
           <div class="main-title">Vote Maximizer</div>
       </div>
       <div class="map-container">
           <div class="col" id="map"></div>
       </div>
       <div class="legend-container">
           <fieldset>
               <form action="/local" method="post">
                   <div class="input-group">
                       <label for="location">Find pivotal elections near you:</label>
                       <input type="text" class="form-control" id="location" name="location" placeholder="Type address/ZIP, press enter">
                   </div>  
               </form>

               <div id="legend-section" class="legend-section">
                   <div id="legend-box">
                       <div class="legend-items"> 
                           <button class="legend-btn" data-level="democracy" style="background-color: #9277DE;">
                               Democracy repair
                           </button>
                       </div>
                       <div class="legend-items">
                           <button class="legend-btn" data-level="president" style="background-color: #F5928D;">
                               President
                           </button>
                       </div>
                       <div class="legend-items">
                           <button class="legend-btn" data-level="senate" style="background-color: #fec548;">
                               Senate
                           </button>
                       </div> 
                       <div class="legend-items">
                           <button class="legend-btn" data-level="house" style="background-color: #B4CDE3;">
                               House
                           </button>
                       </div>  
                       <div class="legend-items">
                           <button class="legend-btn" data-level="statewide" style="background-color: #D19E9B;">
                               State
                           </button>
                       </div>
                       <div class="legend-items">
                           <button class="legend-btn" data-level="abortion" style="background-color: #F768A0;">
                               Abortion
                           </button>
                       </div>
                       <div class="legend-items">
                           <button class="legend-btn" data-level="ballot_all" style="background-color: #13DDB7;">
                                Ballot Measures
                           </button>
                       </div>
                   </div>
               </div>
           </fieldset>
       </div>

<script type="module">    
        const states = JSON.parse('{{ states | tojson }}')
        let stateWideRaces = ["AK","AZ","DE","IN","MO","MT","KS","MI","MN","ND","UT","VT","WA","WV","NE","NV","NH","PA","WI","NC"];
        import voterEmpowerment from './static/js/voter_empowerment.js';
        import ballotData from './static/js/ballots.js';
        import stateData from './static/js/stateData.js';
        const abortionData= ballotData.filter(initiative => 
            initiative.ballot_type.toLowerCase().includes("reproductive")
        );
        const LEVELS = ['democracy', 'president', 'senate', 'house', 'state', 'abortion', 'key_ballot']
        let animationRunning = true;
        const COLOR_BG = '#F2F3F4';  // Define your background color
        const COLOR_HOVER = '#FFFFFF';
        const COLOR_DEMOCRACY = '#9277DE';
        const COLOR_PRESIDENT = '#F5928D';
        const COLOR_SENATE  = '#fec548'
        const COLOR_HOUSE = '#B4CDE3';
        const COLOR_GOVERNOR = '#13DDB7';
        const COLOR_STATE_LEGISLATURE = '#D19E9B';
        const COLOR_ABORTION = '#F768A0';
        const COLOR_KEY_BALLOT = '#13DDB7';
        const COLOR_DEFAULT  = '#e1e1e1'; // Default color for unmatched cases
        const COLOR_BORDER = '#EEEEEE';
        const COLOR_BORDER_LEG = '#000000';// Border color for all layers

        const democracyScale = interpolateColors(COLOR_DEFAULT, COLOR_DEMOCRACY, 5);
        const presidentScale = interpolateColors(COLOR_DEFAULT, COLOR_PRESIDENT, 5);
        const houseScale = interpolateColors(COLOR_DEFAULT, COLOR_HOUSE, 5)
        const senateScale = interpolateColors(COLOR_DEFAULT, COLOR_SENATE, 5)
        const govScale = interpolateColors(COLOR_DEFAULT, COLOR_GOVERNOR, 5)
        const stateLegScale = interpolateColors(COLOR_DEFAULT, COLOR_STATE_LEGISLATURE, 5) 
        const abortionScale = interpolateColors(COLOR_DEFAULT, COLOR_ABORTION, 5)
        const keyBallotScale = interpolateColors(COLOR_DEFAULT, COLOR_KEY_BALLOT, 5)

        // Set the background color of the body
        document.body.style.backgroundColor = COLOR_BG;
        mapboxgl.accessToken = '{{ mapbox_key }}';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mikeklein1/cm0h4ib4o01mf01qv90n802b8/draft',
            zoom: 3.5, // Adjust as needed
            maxZoom: 5,
            minZoom: 2,
            center: [0,-2],
            projection: 'mercator', // Using an equal-area projection,
            background: COLOR_BG  // Use the same color for the map background
        });
        // Function to interpolate between two colors
        function interpolateColor(color1, color2, factor) {
            const result = color1.slice();
            for (let i = 0; i < 3; i++) {
                result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
            }
            return result;
        }
        // Function to convert hex to RGB
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }
        // Function to convert RGB to hex
        function rgbToHex(rgb) {
            return "#" + rgb.map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }).join('');
        }

        // Combined function for both cases
        function interpolateColors(startColor, endColor, steps, extendRange = false) {
            const start = hexToRgb(startColor);
            const end = hexToRgb(endColor);
            const colors = [];

            if (extendRange) {
                // Case 2: Create a darker version of the end color
                const darkerEnd = end.map(c => Math.max(0, c - 40));
                steps += 1; // Add an extra step for the darker color

                for (let i = 0; i < steps; i++) {
                    const factor = i / (steps - 1);
                    const interpolated = i === steps - 1 
                        ? darkerEnd 
                        : interpolateColor(start, end, factor);
                    colors.push(rgbToHex(interpolated));
                }
            } else {
                // Case 1: Standard interpolation
                for (let i = 0; i < steps; i++) {
                    const factor = i / (steps - 1);
                    const interpolated = interpolateColor(start, end, factor);
                    colors.push(rgbToHex(interpolated));
                }
            }

            return colors;
        }

        //add all the layers as const here
        const layers = {
    
            starting: 'static/data/calculated_files/geojsons/overall_albers.geojson',
            abortion: 'static/data/geojson_imports/geojson_final/ballot_abort_albers.geojson',
            democracy: 'static/data/geojson_imports/geojson_final/ballot_VPM_albers.geojson',
            aggregate: 'static/data/calculated_files/geojsons/aggregate_albers.geojson',
            presidential: 'static/data/calculated_files/geojsons/president_albers.geojson',
            senate: 'static/data/calculated_files/geojsons/senate_albers.geojson',
            house: 'static/data/geojson_imports/geojson_final/house_albers.geojson',
            statewide: 'static/data/calculated_files/geojsons/governor_albers.geojson',
            ballot_all: 'static/data/geojson_imports/geojson_final/ballot_initiatives_main_albers.geojson',
            state_leg_up:'static/data/geojson_imports/geojson_final/state_leg_upper_albers.geojson',
            state_leg_low:'static/data/geojson_imports/geojson_final/state_leg_lower_albers.geojson'        
        };

        const geoJsonCache = {};

        async function loadGeoJson(layerId) {
            if (geoJsonCache[layerId]) {
                return geoJsonCache[layerId];
            }
            const startTime = performance.now();
            try {
                const response = await fetch(layers[layerId]);
                const data = await response.json();
                geoJsonCache[layerId] = data;
                
                const endTime = performance.now();
                const downloadTime = (endTime - startTime) / 1000; // Convert to seconds
                
                return data;
            } catch (error) {
                throw error;
            }
        }

        let hoveredStateId = null; // This will hold the ID of the feature under the mouse.
        let currentLayerId = 'starting'; // adjust the layer that pops up first here

        const popup = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false
        });
        

        function addGeoJsonLayer(layerId) {
            const idProperty = layerId === 'house' || layerId === 'state_leg_up' || layerId === 'state_leg_low' ? 'GEOIDFQ' : 'STATEFP';  //  'house' uses GEOIDFQ, others use STATEFP for unique id

            // remove hover state when switching layers
            if (hoveredStateId) {
                map.setFeatureState({source: currentLayerId, id: hoveredStateId}, { hover: false });
                hoveredStateId = null;
            }

            // Remove existing layers
            if (map.getSource(currentLayerId)) {
                map.removeLayer(currentLayerId + '-fill');
                map.removeLayer(currentLayerId + '-line');
                map.removeLayer(currentLayerId + '-hover-line');  // Remove hover line if it exists
                map.removeSource(currentLayerId);

            }

            // Adds the geojson layers
            map.addSource(layerId, {
                type: 'geojson',
                data: layers[layerId],
                promoteId: idProperty  
            });
        
   
    if (layerId === 'ballot_all') {
        map.addLayer({
            id: layerId + '-fill',
            type: 'fill',
            source: layerId,
            paint: {
            'fill-color': [
                'case',
                ['all', 
                    ['!=', ['get', 'number_per_state'], null],
                    ['!=', ['get', 'number_per_state'], 0]
                ], COLOR_KEY_BALLOT,
                COLOR_DEFAULT,
            ],
            'fill-opacity': 1, // 100% opaque
        }
        }, 'albersusa-points'); // state names should be over the layers
    } else if (layerId === 'statewide') {
        //stateWideRaces = stateWideRaces.map(String); // Convert all elements to strings
        // Filter stateData for the current state and find max voter power
        const stateMaxVoterPower = {};
        const stateNames = [...new Set(stateData.map(race => race.state_name))];
        
        stateNames.forEach(stateName => {
            const stateRaces = stateData.filter(race => race.state_name === stateName);
            const maxVoterPower = Math.max(...stateRaces.map(race => parseInt(race.voter_power) || 0));
            stateMaxVoterPower[stateName] = maxVoterPower;
        });

        const stateRaces = stateData.filter(race => parseInt(race.voter_power) >= 20);
        const maxVoterPower = Math.max(...stateRaces.map(race => parseInt(race.voter_power) || 0));
        const statesToPaint = Object.keys(stateMaxVoterPower).filter(state => stateMaxVoterPower[state] >= 20)
        stateWideRaces = statesToPaint.map(String);
        map.addLayer({
            id: layerId + '-fill',
            type: 'fill',
            source: layerId,
            paint: {
                'fill-color': [
                    'case',
                    ['in', ['get', 'NAME'], [ 'literal', stateWideRaces] ],
                    COLOR_STATE_LEGISLATURE,
                    COLOR_DEFAULT
                ],
                'fill-opacity': 1
            }
        }, 'albersusa-points');

    } else if (layerId === 'starting') {

        const races = voterEmpowerment['democracy'].map(String);
        map.addLayer({
            id: layerId + '-fill',
            type: 'fill',
            source: layerId,
            paint: {
                'fill-color': [
                    'case',
                    ['in', ['get', 'STUSPS'], [ 'literal', races] ],
                    COLOR_DEMOCRACY,
                    COLOR_DEFAULT
                ],
                'fill-opacity': 1
            }
        }, 'albersusa-points');
    } else if (layerId === 'overall') {
        map.addLayer({
            id: layerId + '-fill',
            type: 'fill',
            source: layerId,
            filter: ['!=', ['get', 'STATEFP'], '72'], // Exclude Puerto Rico
            paint: {
                    'fill-color': [
                        'match',
                        ['get', 'power_level'],
                        'democracy', COLOR_DEMOCRACY,  // Color for score 1
                        'president', COLOR_PRESIDENT,  // Color for score 2
                        'senate', COLOR_SENATE,  // Color for score 3
                        'house', COLOR_HOUSE,  // Color for score 4
                        'governor', COLOR_GOVERNOR,  // Color for score 5
                        'state legislature', COLOR_STATE_LEGISLATURE,  // Color for score 6
                        COLOR_DEFAULT,    // Default color if no match
                    ],
                    'fill-opacity': 1,
                }
        }, 'albersusa-points'); // state names should be over the layers
    } else if (layerId === 'abortion') {
        // Filter abortionData to get a list of only the state names
        const abortionStates = abortionData.map(initiative => initiative.state_name).map(String);
        map.addLayer({
            id: layerId + '-fill',
            type: 'fill',
            source: layerId,
            paint: {
                'fill-color': [
                    'case',
                    ['in', ['get', 'NAME'], [ 'literal', abortionStates] ],
                    COLOR_ABORTION,
                    COLOR_DEFAULT
                ],
                'fill-opacity': 1
            }
        }, 'albersusa-points');
    } else if (layerId === 'democracy') {
        map.addLayer({
            id: layerId + '-fill',
            type: 'fill',
            source: layerId,
            filter: ['!=', ['get', 'STATEFP'], '72'], // Exclude Puerto Rico
            paint: {
                'fill-color': [
                    'case',
                    ['>', ['to-number', ['get', 'number_per_state'] ], 0], COLOR_ABORTION,
                    COLOR_DEFAULT
                ],
                'fill-opacity': 1,
            }
        }, 'albersusa-points');
    } else if (layerId === 'house') {
        const data = geoJsonCache[layerId];
        map.addLayer({
            id: layerId + '-fill',
            type: 'fill',
            source: layerId,
            paint: {   
                'fill-color': [
                    'case',
                    ['any', 
                        ['==', ['get', 'voter_power'], null],
                        ['==', ['get', 'voter_power'], 0]
                    ],
                    COLOR_DEFAULT,
                    [
                        'interpolate',
                        ['linear'],
                        ['get', 'voter_power'],
                        //1, houseScale[0],
                        20, houseScale[1],
                        50, houseScale[2],
                        75, houseScale[3],
                        100, houseScale[4]
                    ]
                ],
                'fill-opacity': 1
            }
        }, 'albersusa-points');
    } else {
        if (layerId === 'senate') {
            console.log('senate layer');
        }
        map.addLayer({

    id: layerId + '-fill',
    type: 'fill',
    source: layerId,
    filter: ['!=', ['get', 'STATEFP'], '72'], // Exclude Puerto Rico
    paint: {
        'fill-color': [
            'case',
            ['==', ['get', 'voter_power'], null], COLOR_DEFAULT, //  undefined voter_power is grey
            ['==', ['get', 'voter_power'], 0], COLOR_DEFAULT, //  zero voter_power is also grey
            
            ['==', layerId, 'aggregate'], [
                'interpolate', ['linear'], ['get', 'voter_power'],
                1, '#ffffd4', 33.3, '#fed98e', 66.6, '#fe9929', 100, '#cc4c02'
            ],

            ['==', layerId, 'presidential'], [
                'interpolate', ['linear'], ['get', 'voter_power'],
                1, presidentScale[0],
                25, presidentScale[1],
                50, presidentScale[2],
                75, presidentScale[3],
                100, presidentScale[4]
            ],
            ['==', layerId, 'senate'], [
                'interpolate', ['linear'], ['get', 'voter_power'],
                1, senateScale[0],
                25, senateScale[1],
                50, senateScale[2],
                75, senateScale[3],
                100, senateScale[4]
            ],
            ['==', layerId, 'gubernatorial'], [
                'interpolate', ['linear'], ['get', 'voter_power'],
                1, govScale[0],
                25, govScale[1],
                50, govScale[2],
                75, govScale[3],
                100, govScale[4]
            ],
            ['==', layerId, 'state_leg_up'], [
                'case',
                ['>', ['get', 'voter_power'], 20], COLOR_STATE_LEGISLATURE,
                COLOR_DEFAULT
            ],
            ['==', layerId, 'state_leg_low'], [
                'interpolate', ['linear'], ['get', 'voter_power'],
                1, stateLegScale[0],
                25, stateLegScale[1],
                50, stateLegScale[2],
                75, stateLegScale[3],
                100, stateLegScale[4]
            ],
            COLOR_DEFAULT  // Default color for unmatched cases
        ],
        'fill-opacity': 1
    }

                }, 'albersusa-points');
            }
            // line layer to seperate states or districts
            map.addLayer({
                id: layerId + '-line',
                type: 'line',
                source: layerId,
                layout: {},
                paint: {
                    'line-color': [
                        'case',
                        ['==', layerId, 'state_leg_up'], COLOR_BORDER_LEG,
                        COLOR_BORDER
                    ],
                    'line-width': [
                        'case',
                        ['==', layerId, 'state_leg_up'], 0.5,
                        1.5
                    ],
                    'line-opacity': 1
                }
            }, 'albersusa-points');

            // add line layer that highlights when hovering 
            map.addLayer({
                id: layerId + '-hover-line',
                filter: ['!=', ['get', 'STATEFP'], '72'], // Exclude Puerto Rico
                type: 'line',
                source: layerId,
                layout: {},
                paint: {
                    'line-color': ['case', ['boolean', ['feature-state', 'hover'], false], COLOR_HOVER, COLOR_BORDER],
                    'line-color-transition': { duration: 1000 },
                    'line-width': ['case', ['boolean', ['feature-state', 'hover'], false], 4, 2],
                    'line-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0],
                }
            });

            // put hover line  above others
            map.moveLayer(layerId + '-hover-line');

            map.on('click', layerId + '-fill', function (e) {
            //e.preventDefault(); 
            // test the feature.properties
            const features = map.queryRenderedFeatures(e.point);
            
            if (!features.length) {
                    return;
                };
                let feature = map.queryRenderedFeatures(e.point, { layers: [layerId + '-fill'] })[0];
                let location;
                if (feature) {
                    location = feature.properties['state_name'];
                    if (location && states.includes(location)) {
                        window.location.href = `/state?location=${location}`;
                        return;
                    }
                }
                if (!location) {
                    feature = map.queryRenderedFeatures(e.point, { layers: ['albersusa'] })[0];
                    location = feature.properties['state_name'];
                    if (location && states.includes(location)) {
                        window.location.href = `/state?location=${location}`;
                        return;
                    }
                }
            });

            // mouse event for hovering
map.on('mousemove', layerId + '-fill', function (e) {
    if (e.features.length > 0) {
        const feature = e.features[0];
        const currentId = feature.properties[idProperty]; // Make sure this is the field you promote as ID

        //console.log("Feature ID:", feature.id, "Current ID:", currentId);  // Logging feature ID for debugging
        
        if (hoveredStateId !== currentId) {
            if (hoveredStateId) {
                map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: false });
            }
            hoveredStateId = currentId;
            map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: true });
        }

        let popupContent = ""; // Initialize popupContent
        const name = feature.properties['NAME'] || feature.properties['NAMELSAD'] || feature.properties['election_name'];
        let voterPower = feature.properties['voter_power']; // Directly use the property

        if (layerId === 'ballot_all') {
            // Check if the description is undefined or empty
            var description = feature.properties['number_per_state'];
            if (description === undefined || description === '') {
                popupContent = `<div class="custom-popup">
                    <strong>State:</strong> ${name}<br>
                    There are no ballot initiatives in your state.
                </div>`;
            } else {
                popupContent = `<div class="custom-popup">
                    <strong>State:</strong> ${name}<br>
                    <strong>Total initiatives:</strong> ${description}
                    <br>Click the state to learn more.<br>
                </div>`;
            }
        } else if (layerId === 'abortion') {
            const stateName = feature.properties['NAME'];
            // Filter ballotData for abortion initiatives in the current state
            const stateAbortionInitiatives = abortionData.filter(initiative => initiative.state_name === stateName); 
               
            var description = stateAbortionInitiatives.length;
            if (description <= 0) {
                popupContent = `<div class="custom-popup">
                    <strong>There are no abortion ballot initiatives in your state.</strong>
                </div>`;
            } else {
                popupContent = `<div class="custom-popup">
                    <strong>${stateName} has reproductive rights on the ballot.</strong> 
                    <br>Click the state to learn more.<br>
                </div>`;
            }
        } else if (layerId === 'statewide') {
            const stateName = feature.properties['NAME'];
            // Filter stateData for the current state and find max voter power
            const stateRaces = stateData.filter(race => race.state_name === stateName);
            const maxVoterPower = Math.max(...stateRaces.map(race => parseInt(race.voter_power) || 0));
            if (stateRaces.length === 0 || maxVoterPower === 0) {
                popupContent = `<div class="custom-popup">
                    <strong>State: ${stateName}</strong>
                    <br>No competitive races.<br>
                </div>`;
            } else {
                popupContent = `<div class="custom-popup">
                    <strong>State: ${stateName}.</strong>
                    <br><strong>Maximum Voter Power:</strong> ${maxVoterPower}
                    <br>Click the state to learn more.<br>
                </div>`;
            }

        } else if (layerId === 'democracy') {
            var description = feature.properties['number_per_state'];
            if (description === undefined || description === '' || description === 0) {
                popupContent = `<div class="custom-popup">
                    <strong>State:</strong> ${name}<br>
                    <strong>No democracy initiatives.</strong>
                </div>`;
            } else {
                popupContent = `<div class="custom-popup">
                    <strong>State:</strong> ${name}<br>
                    <strong>Democracy initiatives: ${description}</strong><br>
                    Click the state to learn more.
                </div>`;
            }
        }else if (layerId === 'starting'){
            popupContent = `<div class="custom-popup">
                <strong>State:</strong> ${name}
                <br>Click the state to learn more.<br>
            </div>`;

        } else if (layerId === 'house' && (!voterPower || voterPower === 'no race')) {
            // Specific case for house layer with undefined voter power
            popupContent = `<div class="custom-popup">
                <strong>District:</strong> ${name}<br>
                No competitive race.
            </div>`;
        } else if (layerId === 'overall') {
            // Handle overall case
            let powerLevel = feature.properties['power_level'];
            powerLevel = powerLevel[0].toUpperCase() + powerLevel.slice(1);
            popupContent = `<div class="custom-popup">
                <strong>State:</strong> ${name}<br>
                <strong>Power Level: ${powerLevel}</strong><br>
                <strong>Voter Power:</strong> ${voterPower}
            </div>`;
        }
        else {
            // Handle other cases
            voterPower = voterPower === undefined ? 'no competitive race' : voterPower; // Check if voter power is undefined
            popupContent = `<div class="custom-popup">
                <strong>${layerId === 'house' || layerId === 'state_leg_up' || layerId === 'state_leg_low' ? 'District' : 'State'}:</strong> ${name}<br>
                <strong>Voter Power:</strong> ${voterPower}
            </div>`;
        }
            
                    popup.setLngLat(e.lngLat).setHTML(popupContent).addTo(map);
                    map.getCanvas().style.cursor = 'pointer';
                } else {
                    if (hoveredStateId) {
                        map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: false });
                        hoveredStateId = null;
                    }
                    map.getCanvas().style.cursor = '';
                    popup.remove();
                }
            });

            map.on('mouseleave', layerId + '-fill', function () {
                if (hoveredStateId) {
                    map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: false });
                    hoveredStateId = null;
                }
                map.getCanvas().style.cursor = '';
                popup.remove();
            });

            // Update the current layer ID
            currentLayerId = layerId;
        }

map.on('load', async function () {
    try {
        const startingData = await loadGeoJson('starting');
        addGeoJsonLayer('starting', startingData);

        // Lazy load other layers
        Object.keys(layers).forEach(layerId => {
            if (layerId !== 'starting') {
                loadGeoJson(layerId);
            }
        });
    } catch (error) {
        console.error('Error during initial map setup:', error);
    }

    // Set initial color for all states
    //map.setPaintProperty('starting-fill', 'fill-color', COLOR_DEFAULT);

    // Wait for the source to load
    map.once('idle', function() {   
        let animationId;
        let features = [];
        let allFeatures = [];
        let powerLevels = LEVELS;
        let currentPowerLevelIndex = 0;
        let skipFadeFirst = true;
        let fadeInDelay = 1500;
        const nextGroupDelay = 2000; // Increased delay between power levels
        const fadeOutDelay = 1500;
        const steps = 30;
        const stateColors = new Map();
        const stateOpacities = new Map();

        function queryFeatures() {
            allFeatures= map.queryRenderedFeatures({ layers: ['starting-fill'] });
            
            features = allFeatures.filter((feature, index, self) =>
                index === self.findIndex((t) => (
                    t.properties.STATEFP === feature.properties.STATEFP
                )) && feature.properties.power_level !== "none"
            );

            if (features.length > 0) {
                animateNextPowerLevel();
            } else {
                console.error("No features found. Retrying in 1 second...");
                setTimeout(queryFeatures, 1000);
            }
        }
        queryFeatures();

        async function animateNextPowerLevel() {
            if (!features || features.length === 0) {
                console.error("Features not loaded yet. Retrying in 1 second...");
                setTimeout(animateNextPowerLevel, 1000);
                return;
            }
            if (skipFadeFirst) {
                fadeInDelay = 0;
                skipFadeFirst = false;
            }
            else {
                fadeInDelay = 1500;
            }

            if (currentPowerLevelIndex >= powerLevels.length) {
                currentPowerLevelIndex = 0;
            } 
                const currentPowerLevel = powerLevels[currentPowerLevelIndex];
                console.log("Animating power level: ", currentPowerLevel);
                
                let statesToAnimate = features.filter(feature => 
                        voterEmpowerment[currentPowerLevel].includes(feature.properties.STUSPS)
                    );
                const targetColor = getColorForPowerLevel(currentPowerLevel);
                // Set all states to default fill-color
                allFeatures.forEach(feature => {
                    const stateId = feature.properties.STATEFP;
                    stateColors.set(stateId, COLOR_DEFAULT);
                    stateOpacities.set(stateId, 1); 
                });
                updateMapColors();


                // Get the button with the data-level matching currentPowerLevel and add "highlight" class
                const currentButton = document.querySelector(`.legend-btn[data-level="${currentPowerLevel}"]`);
                if (currentButton) {
                    currentButton.classList.add('highlight');
                }
                console.log('currentButton', currentButton);

                // Remove "highlight" class from other buttons
                document.querySelectorAll('.legend-btn').forEach(button => {
                    if (button !== currentButton) {
                        button.classList.remove('highlight');
                    }
                });
                await animateStates(statesToAnimate, targetColor, true);
                currentPowerLevelIndex++;
                // Use Promise-based setTimeout
                await new Promise(resolve => setTimeout(resolve, nextGroupDelay));
                await fadeOutStates(statesToAnimate);
                if (animationRunning) { 
                    animateNextPowerLevel(); // Continue to next power level
                }

        }

        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        }

        function animateStates(states, targetColor,useLinearFade = false) {
            return new Promise((resolve) => {
                const opacityDelay = fadeInDelay / steps;
                
                states.forEach(feature => {
                    const stateId = feature.properties.STATEFP;
                    stateColors.set(stateId, targetColor);
                });
                
                for (let i = 0; i <= steps; i++) {
                    setTimeout(() => {
                        //adding one prevents ever being 0
                        const t = (i + 1) / (steps + 1);
                        const opacity = useLinearFade ? t : easeInOutQuad(t);
                        states.forEach(feature => {
                            const stateId = feature.properties.STATEFP;
                            stateOpacities.set(stateId, opacity);
                        });
                        updateMapColors();
                        if (i === steps) resolve(); // Resolve the promise when animation is complete
                    }, i * opacityDelay);
                }
            });
        }

        function fadeOutStates(states) {
            return new Promise((resolve) => {
                const opacityDelay = fadeOutDelay / steps;
                
                for (let i = steps; i >= 0; i--) {
                    setTimeout(() => {
                        const t = i / steps;
                        const opacity = easeInOutQuad(t);
                        states.forEach(feature => {
                            const stateId = feature.properties.STATEFP;
                            stateOpacities.set(stateId, opacity);
                        });
                        updateMapColors();
                        if (i === 0) {
                            states.forEach(feature => {
                                const stateId = feature.properties.STATEFP;
                                stateColors.set(stateId, COLOR_DEFAULT);
                            });
                            updateMapColors();
                            resolve();
                        }
                    }, (steps - i) * opacityDelay);
                }
            });
        }

        function updateMapColors() {
            const colorExpression = [
                'match',
                ['get', 'STATEFP'],
                ...Array.from(stateColors).flatMap(([statefp, color]) => [statefp, color]),
                COLOR_DEFAULT
            ];

            const opacityExpression = [
                'match',
                ['get', 'STATEFP'],
                ...Array.from(stateOpacities).flatMap(([statefp, opacity]) => [statefp, opacity]),
                0.1 // Default opacity for states not yet animated
            ];


            if (map.getLayer('starting-fill')) {
                map.setPaintProperty('starting-fill', 'fill-color', colorExpression);
                map.setPaintProperty('starting-fill', 'fill-opacity', opacityExpression);
            } else {
                console.error("Layer 'starting-fill' does not exist");
            }
        }

        function stopAnimation() {
            if (animationId) {
                clearTimeout(animationId);
            }
        }
    });
});

function getColorForPowerLevel(powerLevel) {
    switch(powerLevel) {
        case 'democracy': return COLOR_DEMOCRACY;
        case 'president': return COLOR_PRESIDENT;
        case 'senate': return COLOR_SENATE;
        case 'house': return COLOR_HOUSE;
        case 'governor': return COLOR_GOVERNOR;
        case 'abortion': return COLOR_ABORTION;
        case 'key_ballot': return COLOR_KEY_BALLOT;
        case 'state': return COLOR_STATE_LEGISLATURE;
        default: return COLOR_DEFAULT;
    }
}

// Add click event listener for legend buttons
document.querySelectorAll('.legend-btn').forEach(button => {
    button.addEventListener('click', function() {
        //stop the animation
        animationRunning = false;
        const powerLevel = this.getAttribute('data-level');
        const color = getColorForPowerLevel(powerLevel);
        
        console.log("Power level clicked : ", powerLevel);
        // Remove active class from all buttons
        document.querySelectorAll('.legend-btn').forEach(btn => {
            btn.classList.remove('active');
            btn.classList.remove('highlight');
        });
        
        // Add active class to clicked button
        this.classList.add('active');
        this.classList.add('highlight');
        
        // Filter the map to show only states with the selected power level
        // Change the layer to the one that is clicked
        if (powerLevel === 'democracy') {
            addGeoJsonLayer('democracy');
        } else if (powerLevel === 'president') {
            addGeoJsonLayer('presidential');
        } else if (powerLevel === 'senate') {
            addGeoJsonLayer('senate');
        } else if (powerLevel === 'house') {
            addGeoJsonLayer('house');
        } else if (powerLevel === 'statewide') {
            addGeoJsonLayer('statewide');
        } else if (powerLevel === 'abortion') {
            addGeoJsonLayer('abortion');
        } else if (powerLevel === 'ballot_all') {
            addGeoJsonLayer('ballot_all');
        }
    });
});

document.getElementById('location').addEventListener('keypress', function (e) {
    if (e.key === 'Enter') {
        e.preventDefault(); // Prevent the default action (form submission)
        e.target.form.submit(); // Submit the form
    }
});
    </script>
</body>
{% endblock %}
