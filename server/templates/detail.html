{% extends "layout.html" %}
{% block main %}

<link rel="stylesheet" href="./static/detail.css">

<div class="detail-page">
    <body>
        

    <div class="row" height="100%">
        <div class="col" id="detail-left">

            <ul class="list-group" id="state-data-list">
                <!-- State data will be dynamically inserted here -->
            </ul>
        </div>

        <div class="col" id="detail-right">
            <div class="map-overlay">
                <div class="map-overlay-inner">


                    <fieldset>
                        <label for="layer-dropdown">Currently viewing: </label>
                        <div class="dropdown">
                            <button class="dropbtn">Choose Layer</button>
                            <div class="dropdown-content" id="layer-dropdown">
                                <div data-value="ballot_vpm" selectionValue="democracy">Democracy ballot initiatives</div>
                                <div data-value="presidential2" selectionValue="presidential">Presidential race</div>
                                <div data-value="congressional2" selectionValue="senate">Senate race</div>
                                <div data-value="house2" selectionValue="house">House races</div>
                                <div data-value="ballot_abort" selectionValue="abortion">Reproductive rights initiatives</div>
                                <div data-value="ballot_others" selectionValue="others">State-level ballot issues</div>
                            </div>
                        </div>
                       
                      
                        <select id="layer" name="layer" style="display:none;">
                            <option value="ballot_vpm" selectionValue="democracy">Democracy ballot initiatives</option>
                            <option value="presidential2" selectionValue="presidential">Presidential race</option>
                            <option value="congressional2" selectionValue="senate">Senate race</option>
                            <option value="house2" selectionValue="house">House races</option>
                            <option value="ballot_abort" selectionValue="abortion">Reproductive rights initiatives</option>
                            <option value="ballot_others" selectionValue="others">State-level ballot issues</option>
                        </select>
                    </fieldset>
                </div>

                <div class="map-pop">
                    Mouseover for more info
                </div>
        
                <div class="col map-container-sm">
                    <div id="map"></div>  
                    
                </div>

            </div>

            <div class='pin bounce'></div>
            <div class='pulse'></div>

            

        </div>

        
     
</div>
<script type="module">

    
//convert dropdown to select
document.querySelectorAll('#layer-dropdown div').forEach(item => {
    item.addEventListener('click', function() {
        //get clicked data-value and selectionValue
        let selectedValue = this.getAttribute('data-value');
        let selectedText = this.getAttribute('selectionValue');

        let selectElement = document.getElementById('layer');
        selectElement.value = selectedValue;
        
        selectElement.dispatchEvent(new Event('change'));

        //update the url with the selected text
        const currentURL = new URL(window.location.href);
        currentURL.searchParams.set('selection', selectedText);

        //update the url without refreshing the page
        history.pushState(null, '', currentURL);
    });
});

    // Create a master dictionary to hold all state data
    let masterStateData = {};

    // List of all categories
    const allCategories = ['presidential', 'senate', 'house', 'state_house', 'state_senate', 'governor', 'democracy_repair_ballots', 'state_level_ballots'];

    // Function to add data to the master dictionary
    function addToMasterData(dataList, category) {
        dataList.forEach(item => {
            const state = typeof item.state_name === 'string' ? item.state_name.trim() : 'Unknown';
            
            // Initialize state object if it doesn't exist
            if (!masterStateData[state]) {
                masterStateData[state] = {};
                // Initialize all categories as empty arrays
                allCategories.forEach(cat => {
                    masterStateData[state][cat] = [];
                });
            }
            
            // Add the item to the appropriate category
            masterStateData[state][category].push(item);
        });
    }

    // Process each data list
    addToMasterData({{ pres_list | tojson | safe }}, 'presidential');
    addToMasterData({{ senate_list | tojson | safe }}, 'senate');
    addToMasterData({{ house_list | tojson | safe }}, 'house');
    addToMasterData({{ state_house_list | tojson | safe }}, 'state_house');
    addToMasterData({{ state_senate_list | tojson | safe }}, 'state_senate');
    addToMasterData({{ governor_list | tojson | safe }}, 'governor');
    addToMasterData({{ dem_ballot_list | tojson | safe }}, 'democracy_repair_ballots');
    addToMasterData({{ state_level_list | tojson | safe }}, 'state_level_ballots');
    console.log("masterStateData first:", masterStateData);
       // Function to fetch ballot initiatives
    async function fetchBallotInitiatives() {
        try {
            const response = await fetch('/api/ballot_initiatives');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text = await response.text(); // Get the response as text first
            try {
                return JSON.parse(text); // Try to parse the text as JSON
            } catch (parseError) {
                console.error('Error parsing JSON:', parseError);
                console.error('Raw text:', text);
                return []; // Return an empty array if parsing fails
            }
        } catch (error) {
            console.error('Error fetching ballot initiatives:', error);
            return [];
        }
    }

 
    // Modified integrateBallotData function
    async function integrateBallotData() {
        const ballotInitiativesData = await fetchBallotInitiatives();
        console.log('Ballot Initiatives Data:', ballotInitiativesData);
        
        if (!Array.isArray(ballotInitiativesData)) {
            console.error('Ballot initiatives data is not an array:', ballotInitiativesData);
            return; // Exit the function if data is not in the expected format
        }      
        Object.keys(masterStateData).forEach(state => {
            if (!masterStateData[state].ballot_initiatives) {
                masterStateData[state].ballot_initiatives = [];
            }
            const stateInitiatives = ballotInitiativesData.filter(initiative => 
                initiative.state_name === state
            );
            masterStateData[state].ballot_initiatives = stateInitiatives;

            // Integrate with existing ballot categories
            stateInitiatives.forEach(initiative => {
                let targetCategory;
                if (initiative.race_type === "Democracy Repair") {
                    targetCategory = 'democracy_repair_ballots';
                } else {
                    targetCategory = 'state_level_ballots';
                }

                if (masterStateData[state][targetCategory]) {
                    const matchingItem = masterStateData[state][targetCategory].find(item => 
                        item.election_name === initiative.election_name
                    );

                    if (matchingItem) {
                        // Merge the new data from the initiative into the existing item
                        Object.assign(matchingItem, initiative);
                    } else {
                        // If no matching item found, add the initiative as a new item
                        masterStateData[state][targetCategory].push(initiative);
                    }
                } else {
                    // If the category doesn't exist, create it and add the initiative
                    masterStateData[state][targetCategory] = [initiative];
                }
            });
        });
    }


    async function initializePage() {
        console.log("Starting page initialization...");
    
        // Populate the state list first
        await populateStateList();
        console.log("State list populated.");
        
        // Then integrate ballot data
        await integrateBallotData();
        console.log("Ballot data integrated.");
        
        console.log("masterStateData after integration:", masterStateData);
        
    }

    initializePage();


    function createCategoryList(categoryData, categoryTitle) {
        // if (!categoryData || categoryData.length === 0) return '';
        
        let tableRows = '';
        let description = '';
        let rowsNonEmpty = (categoryData && categoryData.length > 0)
        let hasElectedOffices = false;

        switch (categoryTitle) {
            case 'Democracy':
                if (rowsNonEmpty) {
                    description = `<p class="category-description-fixed">These initiatives make long-term changes to the practice of democracy in this state.</p>`;
   
                    // Sort categoryData by election_name
                    const sortedCategoryData = [...categoryData].sort((a, b) => {
                        const nameA = (a.election_name || '').toLowerCase();
                        const nameB = (b.election_name || '').toLowerCase();
                        return nameA.localeCompare(nameB);
                    });
                    tableRows += sortedCategoryData.map(item => 
                        `<tr>
                            <td class="text-wrap" colspan="2">
                                <div class="row-name democracy-name">${item['candidate_names'] || item['election_name'] || 'N/A'}</div>
                            </td>
                            <td>
                                <a href="/get-involved?candidates=${item.candidate_ids}&election=${item.eid}" 
                                    class="btn btn-primary btn-info custom-btn">
                                    Learn More
                                </a>   
                            </td>
                        </tr>
                `).join('');
                }
                else {
                    tableRows += `<tr><td colspan="3">No such ballot initiatives exist in this state.</td></tr>`;
                }
                break;

            case 'Elected Offices':
                // <tr class="subcategory-header"><td colspan="3">President</td></tr>
                if (categoryData.president && categoryData.president.voter_power > 20) {
                    hasElectedOffices = true;
                  
                    const item = categoryData.president;
                    const candidate_ids = item.candidate_ids;
                    const election = `${item.state_name} ${item.election_name}`;
                    const election_id = item.eid;


                    tableRows +=`
                        <tr>
                            <td>President</td>
                            <td>${Math.round(categoryData.president.voter_power)}</td>
                            <td>
                                <a href="/get-involved?candidates=${item.candidate_ids}&election=${item.eid}" 
                                    class="btn btn-primary btn-info custom-btn">
                                    Learn More
                                </a>    
                            </td>
                        </tr>
                    `;
                }
                else {
                    tableRows += `<tr><td colspan="3" class="missing">This presidential race does not have high voter power.</td></tr>`;
                }
                
                if (categoryData.senate && categoryData.senate.voter_power > 20) {
                    hasElectedOffices = true;
                    const item = categoryData.senate;

                    tableRows += `
                        <tr>
                            <td>Senate</td>
                            <td>${Math.round(categoryData.senate.voter_power)}</td>
                            <td>
                                 <a href="/get-involved?candidates=${item.candidate_ids}&election=${item.eid}"  
                                    class="btn btn-primary btn-info custom-btn">
                                    Learn More
                                </a>   
                            </td>
                        </tr>
                    `;
                }
                else {
                    tableRows += `<tr><td colspan="3" class="missing">This U.S. Senate race does not have high voter power.</td></tr>`;
                } 
                const highPowerHouseDistricts = categoryData.house.filter(item => item.voter_power > 20);
                
                if (highPowerHouseDistricts && highPowerHouseDistricts.length > 0) {
                    hasElectedOffices = true;
                    tableRows += `<tr class="subcategory-header"><td colspan="3">U.S. House</td></tr>`;
                    tableRows += highPowerHouseDistricts.map(item => `
                        <tr>
                            <td>${item.election_name.replace(/^Congressional\s*/, '').trim() || 'N/A'}</td>
                            <td>${Math.round(item.voter_power)}</td>
                            <td>
                                 <a href="/get-involved?candidates=${item.candidate_ids}&election=${item.eid}" 
                                    class="btn btn-primary btn-info custom-btn">
                                    Learn More
                                </a>   
                            </td>
                        </tr>
                    `).join('');
                }
                else {
                    tableRows += `<tr><td colspan="3" class="missing">No U.S. House races have high voter power.</td></tr>`;
                }
                
                const highPowerStateSenateDistricts = categoryData.state_senate.filter(item => item.voter_power > 20);
                
                if (highPowerStateSenateDistricts && highPowerStateSenateDistricts.length > 0) {
                    
                    tableRows += `<tr class="subcategory-header"><td colspan="3">State Senate</td></tr>`;
                    tableRows += highPowerStateSenateDistricts.map(item => `
                        <tr>
                            <td>${item.election_name.replace(/^State Senate\s*/, '').trim() || 'N/A'}</td>
                            <td>${Math.round(item.voter_power)}</td>
                            <td>
                                 <a href="/get-involved?candidates=${item.candidate_ids}&election=${item.eid}" 
                                    class="btn btn-primary btn-info custom-btn">
                                    Learn More
                                </a>   
                            </td>
                        </tr>
                    `).join('');
                }
                else {
                    tableRows += `<tr><td colspan="3" class="missing">No state senate races have high voter power.</td></tr>`;
                }
                
                const highPowerStateHouseDistricts = categoryData.state_house.filter(item => item.voter_power > 20);
                
                if (highPowerStateHouseDistricts && highPowerStateHouseDistricts.length > 0) {
                    hasElectedOffices = true;
                    tableRows += `<tr class="subcategory-header"><td colspan="3">State House</td></tr>`;
                    tableRows += highPowerStateHouseDistricts.map(item => `
                        <tr>
                            <td>${item.election_name.replace(/^State House\s*/, '').trim() || 'N/A'}</td>
                            <td>${Math.round(item.voter_power)}</td>
                            <td>
                                 <a href="/get-involved?candidates=${item.candidate_ids}&election=${item.eid}" 
                                    class="btn btn-primary btn-info custom-btn">
                                    Learn More
                                </a>   
                            </td>
                        </tr>
                    `).join('');
                }
                else {
                    tableRows += `<tr><td colspan="3" class="missing">No state house races have high voter power.</td></tr>`;
                }                
                break;

            case 'Other ballot initiatives':
                description = '' 

                if (rowsNonEmpty) {
                    const sortedCategoryData = [...categoryData].sort((a, b) => {
                        const typeA = (a.race_type ?? '').toLowerCase();
                        const typeB = (b.race_type ?? '').toLowerCase();
                        const nameA = (a.election_name ?? '').toLowerCase();
                        const nameB = (b.election_name ?? '').toLowerCase();
                        return typeB.localeCompare(typeA) || nameA.localeCompare(nameB);
                    });

                    //tableRows += `<p class="category-description-fixed">Other state-level ballot initiatives:</p>`;
                    tableRows += sortedCategoryData.map(item => `
                    <tr class="tr-whole">
                        <td class="text-wrap" colspan="2">
                            <div class="row-name democracy-name">${item.candidate_names && item.candidate_names.length > 0 ? item.candidate_names : item.election_name}
                            </div>                       
                        </td>

                        <td>
                             <a href="/get-involved?candidates=${item.candidate_ids}&election=${item.eid}" 
                                class="btn btn-primary btn-info custom-btn">
                                Learn More
                            </a>   
                        </td>
                        
                    </tr>
                `).join('');
                } else {
                    tableRows += `<tr><td colspan="3" class="missing">No ballot initiatives in this state.</td></tr>`;
                }
                break;
            }
        // Determine column headers based on category
        let columnHeaders = '';
        if (categoryTitle === 'Democracy' || categoryTitle === 'Other ballot initiatives') {
            if (rowsNonEmpty) {
                columnHeaders = `
                    <tr>
                        <th colspan="2">Initiative</th>
                        <th></th>
                    </tr>
                `;
            }
        } else {
            if (hasElectedOffices) {
                    description = `<p class="category-description-fixed">Elected offices where the <a href="/voter-power" target="_blank">power of individual voters</a> is high:</p>`;
            columnHeaders = `
                <tr>
                    <th>Office</th>
                    <th>Voter Power <span class="vote-info">The power of one more vote (max = 100)</span></th>
                    <th></th>
                </tr>
            `;
        } 
    }

        return `
            <table class="table">
                <thead>
                    <tr class="category-title">
                        <th colspan="3">${categoryTitle}</th>
                    </tr>
                    <tr class="category-description">
                        <td colspan="3">${description}</td>
                    </tr>
                    ${columnHeaders}
                </thead>
                <tbody>
                    ${tableRows}
                </tbody>
            </table>
        `;
    }



    function populateStateList() {
        const stateDataList = document.getElementById('state-data-list');
        stateDataList.innerHTML = ''; // Clear existing content

        for (const state in masterStateData) {
            const stateData = masterStateData[state];
            let stateHtml = `
            
                <div class="state-section" id="state-${state.toLowerCase().replace(/\s+/g, '-')}">
                <h3>${state}</h3>
            `;

            stateHtml += createCategoryList(stateData.democracy_repair_ballots, 'Democracy', state);
            stateHtml += createCategoryList({
                president: stateData.presidential?.[0] ?? [],
                senate: stateData.senate?.[0] ?? [],
                house: stateData.house || [],
                state_senate: stateData.state_senate || [],
                state_house: stateData.state_house || [],
            }, 'Elected Offices');

            stateHtml += createCategoryList(stateData.state_level_ballots , 'Other ballot initiatives', state);

            stateHtml += `</div>`;
            stateDataList.innerHTML += stateHtml;
        }
    }

    function getStateCategoryData(stateName, category) {
        if (stateName === 'ALL') {
            return Object.values(masterStateData).flatMap(state => state[category] || []);
        }
        return masterStateData[stateName]?.[category] || [];
    }
    
    import { 
        COLOR_HOVER, 
        COLOR_DEMOCRACY, 
        COLOR_ABORTION, 
        COLOR_KEY_BALLOT, 
        COLOR_DEFAULT, 
        COLOR_BORDER, 
        COLOR_BORDER_LEG, 
        presidentScale, 
        governorScale, 
        stateLegScale,
        COLOR_BG 
    } from '/static/js/colors.js';
    

        mapboxgl.accessToken = '{{ mapbox_key }}';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mikeklein1/clxkrmlob01s801qkb96q6c00/draft',
            center: ['{{ long }}', '{{ lat }}'],  
            zoom: 5, 
            minZoom: 4,
            maxZoom: 6,
            projection: 'mercator', // Using an equal-area projection,
            background: COLOR_BG 
        });
                
        const geoJsonCache = {};

        async function loadGeoJson(layerId) {
            console.log("Loading GeoJSON for", layerId);
            if (geoJsonCache[layerId]) {
                return geoJsonCache[layerId];
            }

            const maxRetries = 3;
            const baseDelay = 1000; // 1 second

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                const startTime = performance.now();
                try {
                    let data;
                    if (typeof layers[layerId] === 'string') {
                        const response = await fetch(layers[layerId]);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        data = await response.json();
                    } else {
                        data = layers[layerId];
                    }
                    geoJsonCache[layerId] = data;
                    
                    const endTime = performance.now();
                    const downloadTime = (endTime - startTime) / 1000; // Convert to seconds
                    console.log(`GeoJSON for ${layerId} loaded in ${downloadTime.toFixed(2)} seconds`);
                    
                    return data;
                } catch (error) {
                    console.error(`Attempt ${attempt + 1} failed to load ${layerId}:`, error);
                    
                    if (attempt === maxRetries - 1) {
                        console.error(`Failed to load ${layerId} after ${maxRetries} attempts`);
                        throw error;
                    }

                    // Exponential backoff
                    const delay = baseDelay * Math.pow(2, attempt);
                    console.log(`Retrying in ${delay / 1000} seconds...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        const layers = {
            
            //presidential: JSON.parse('{{ pres_layer | safe }}'), 
            //congressional: JSON.parse('{{ senate_layer | safe }}'),
            //house: JSON.parse('{{house_layer | safe }}'),
            //presidential2: 'static/data/calculated_files/geojsons/president.geojson',
            //  congressional2: 'static/data/calculated_files/geojsons/senate.geojson',
            //house2: 'static/data/geojson_imports/geojson_final/house.geojson',
           // gubernatorial: 'static/data/calculated_files/geojsons/governor.geojson',
            //ballot_abort: 'static/data/geojson_imports/geojson_final/ballot_abort.geojson',
            //ballot_vpm: 'static/data/geojson_imports/geojson_final/ballot_VPM.geojson',
            //ballot_sg: 'static/data/geojson_imports/geojson_final/ballot_sg.geojson',
            //ballot_others: 'static/data/geojson_imports/geojson_final/ballot_other.geojson',
            //state_leg_up:'static/data/geojson_imports/geojson_final/state_leg_upper.geojson',
            //state_leg_low:'static/data/geojson_imports/geojson_final/state_leg_lower.geojson',
            baseStatesMap: 'static/data/calculated_files/geojsons/president.geojson',
            houseMap: 'static/data/calculated_files/geojsons/congress_house.geojson',
            stateUpperMap: 'static/data/calculated_files/geojsons/state_upper_legislature.geojson',
            stateLowerMap: 'static/data/calculated_files/geojsons/state_lower_legislature.geojson'
        };

        const senateList = {{senate_list | tojson}};

        let hoveredStateId = null; // This will hold the ID of the feature under the mouse.
        let currentLayerId = 'ballot_vpm'; // Track the current layer

        const popup = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false
        });
        

        // Define popup content generators for each layer type
        const popupContentGenerators = {
            gubernatorial: (feature, config) => `
                <div class="custom-popup">
                    <div class="popup-row"><div class="popup-label"><strong>State:</strong></div><span class="popup-value">${feature.properties.NAME}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Republican running:</strong></div><span class="popup-value">${feature.properties.R_running || 'Not available'}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Democrat running:</strong></div><span class="popup-value">${feature.properties.D_running || 'Not available'}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Voter Power:</strong></div><span class="popup-value">${feature.properties.voter_power || 'No data'}</span></div>
                </div>`,

            presidential: (feature, config) => `
                <div class="custom-popup">
                    <div class="popup-row"><div class="popup-label"><strong>State:</strong></div><span class="popup-value">${feature.properties.NAME}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Republican running:</strong></div><span class="popup-value">${feature.properties.R_running || 'Not available'}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Democrat running:</strong></div><span class="popup-value">${feature.properties.D_running || 'Not available'}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Voter Power:</strong></div><span class="popup-value">${feature.properties.voter_power || 'No data'}</span></div>
                </div>`,

            stateLegislature: (feature, config) => `
                <div class="custom-popup">
                    <div class="popup-row"><div class="popup-label"><strong>District name:</strong></div><span class="popup-value">${feature.properties.NAMELSAD}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Republican running:</strong></div><span class="popup-value">${feature.properties.R_running || 'Not available'}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Democrat running:</strong></div><span class="popup-value">${feature.properties.D_running || 'Not available'}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Voter Power:</strong></div><span class="popup-value">${feature.properties.voter_power || 'No data'}</span></div>
                </div>`,

            ballot: (feature, config) => {
                const ballotName = feature.properties['name.of.ballot'];
                return ballotName === 'Not available'
                    ? '<div class="custom-popup">No ballot initiatives in this state.</div>'
                    : `
                        <div class="custom-popup">
                            <div class="popup-row"><div class="popup-label"><strong>State name:</strong></div><span class="popup-value">${feature.properties.state_name}</span></div>
                            <div class="popup-row"><div class="popup-label"><strong>Ballot name:</strong></div><span class="popup-value">${ballotName}</span></div>
                            <div class="popup-row"><div class="popup-label"><strong>Description:</strong></div><span class="popup-value">${feature.properties.description || 'No description available'}</span></div>
                        </div>`;
            },

            default: (feature, config, layerId) => `
                <div class="custom-popup">
                    <div class="popup-row"><div class="popup-label"><strong>${layerId === 'house' ? 'District' : 'State'}:</strong></div><span class="popup-value">${feature.properties.NAME || feature.properties.NAMELSAD}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Republican running:</strong></div><span class="popup-value">${feature.properties.R_running || 'Not available'}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Democrat running:</strong></div><span class="popup-value">${feature.properties.D_running || 'Not available'}</span></div>
                    <div class="popup-row"><div class="popup-label"><strong>Voter Power:</strong></div><span class="popup-value">${feature.properties.voter_power || 'No competitive race'}</span></div>
                </div>`
        };

        // Update layerConfig to use these generators

        const layerConfig = {
            'presidential': {
                colorScale: presidentScale,
                baseMap: 'baseStatesMap',
                getData: (stateName) => getStateCategoryData(stateName, 'presidential'),
                idProperty: 'state',
                borderColor: COLOR_BORDER,
                borderWidth: 1.5,
                popupContentGenerator: popupContentGenerators.presidential
            },
            'gubernatorial': {
                colorScale: governorScale,
                baseMap: 'baseStatesMap',
                getData: (stateName) => getStateCategoryData(stateName, 'governor'),
                idProperty: 'STATEFP',
                borderColor: COLOR_BORDER,
                borderWidth: 1.5,
                popupContentGenerator: popupContentGenerators.gubernatorial
            },
            'state_leg_up': {
                colorScale: stateLegScale,
                baseMap: 'stateUpperMap',
                getData: (stateName) => getStateCategoryData(stateName, 'state_senate'),
                idProperty: 'GEOIDFQ',
                borderColor: COLOR_BORDER_LEG,
                borderWidth: 0.5,
                popupContentGenerator: popupContentGenerators.stateLegislature
            },
            'state_leg_low': {
                colorScale: stateLegScale,
                baseMap: 'stateLowerMap',
                getData: (stateName) => getStateCategoryData(stateName, 'state_house'),
                idProperty: 'GEOIDFQ',
                borderColor: COLOR_BORDER_LEG,
                borderWidth: 0.5,
                popupContentGenerator: popupContentGenerators.stateLegislature
            },
            'ballot_abort': {
                colorScale: COLOR_ABORTION,
                baseMap: 'baseStatesMap',
                getData: (stateName) => getStateCategoryData(stateName, 'state_level_ballots').filter(ballot => ballot.category === 'abortion'),
                idProperty: 'STATEFP',
                borderColor: COLOR_BORDER,
                borderWidth: 1.5,
                popupContentGenerator: popupContentGenerators.ballot
            },
            'ballot_vpm': {
                colorScale: COLOR_DEMOCRACY,
                baseMap: 'baseStatesMap',
                getData: (stateName) => getStateCategoryData(stateName, 'democracy_repair_ballots'),
                idProperty: 'STATEFP',
                borderColor: COLOR_BORDER,
                borderWidth: 1.5,
                popupContentGenerator: popupContentGenerators.ballot
            },
            'ballot_others': {
                colorScale: COLOR_KEY_BALLOT,
                baseMap: 'baseStatesMap',
                getData: (stateName) => getStateCategoryData(stateName, 'state_level_ballots'),
                idProperty: 'STATEFP',
                borderColor: COLOR_BORDER,
                borderWidth: 1.5,
                popupContentGenerator: popupContentGenerators.ballot
            }
        };

        // Generic function to generate popup content
        function generateGenericPopupContent(feature, config, layerId) {
            const generator = config.popupContentGenerator || popupContentGenerators.default;
            return generator(feature, config,layerId);
        }

        function createFillPaint(layerId, config) {

            let fillPaint;
            const data = config.getData('ALL');
            const idProperty = config.idProperty;
            const unmatchedFeatures = [];

            if (!data || data.length === 0) {
                // If data is empty, return a constant color expression
                return COLOR_DEFAULT;
            }

            if (Array.isArray(config.colorScale)) {
                // Step 1: Group by feature properties and find max voter power
                const stateMaxPower = {};
                console.log('Data for layer:', data);

                for (const item of data) {
                    const stateKey = item.state || item.state_name;
                    const power = Math.round(parseFloat(item.voter_power) || 0);
                    
                    if (!isNaN(power)) {
                        stateMaxPower[stateKey] = Math.max(stateMaxPower[stateKey] || 0, power);
                    }
                }

                console.log('State max power:', stateMaxPower);

                // Step 2: Convert to array for Mapbox expression
                const voterPowerData = Object.entries(stateMaxPower).flatMap(([name, power]) => [name, power]);
                console.log('Voter power data:', voterPowerData);

                // Step 3: Return the fill paint expression
                fillPaint = [
                    'interpolate',
                    ['linear'],
                    ['coalesce',
                        ['match', ['get', config.idProperty],
                            ...voterPowerData,
                            0 // Default value if idProperty is not found in the match
                        ],
                        0 // Default value if coalesce fails
                    ],
                    0, config.colorScale[0],
                    20, config.colorScale[1],
                    40, config.colorScale[2],
                    60, config.colorScale[3],
                    80, config.colorScale[4]
                ];
                console.log('Fill paint expression:', fillPaint);

                // Check for unmatched features
                data.forEach(item => {
                    const stateKey = item.state || item.state_name;
                    if (!stateMaxPower.hasOwnProperty(stateKey)) {
                        unmatchedFeatures.push(item);
                    }
                });
            } else {
                // Handle the case where colorScale is a single color
                const colorData = config.getData('ALL').map(item => [item.state_name || item.NAME, config.colorScale]);
                console.log('Color data for single color:', colorData);
                fillPaint = [
                    'match',
                    ['get', 'NAME'],
                    ...colorData.flat(),
                    COLOR_DEFAULT // Default color if no match is found
                ];
                console.log('Fill paint expression for single color:', fillPaint);

                // Check for unmatched features
                data.forEach(item => {
                    const stateKey = item.state_name || item.NAME;
                    if (!colorData.some(([name]) => name === stateKey)) {
                        unmatchedFeatures.push(item);
                    }
                });
            }

            if (unmatchedFeatures.length > 0) {
                console.warn(`Unmatched features for ${layerId}:`, unmatchedFeatures);
            }

            console.log('Fill paint expression:', fillPaint);
            return fillPaint;
        }

        function inspectGeoJsonSource(layerId, config) {
            const source = map.getSource(layerId);
            if (source) {
                const data = source._data;
                console.log(`Raw GeoJSON data for ${layerId}:`, data);
                
                if (!data) {
                    console.error(`No data found for layer ${layerId}`);
                    return;
                }

                if (typeof data === 'string') {
                    console.log(`Data for ${layerId} is a string (probably a URL). Cannot inspect features directly.`);
                    return;
                }

                if (!data.features || !Array.isArray(data.features)) {
                    console.error(`Unexpected data structure for layer ${layerId}. 'features' array not found.`);
                    return;
                }

                const expectedProperty = config.idProperty;
                const features = data.features;
                console.log(`Number of features in ${layerId}:`, features.length);

                const missingPropertyFeatures = features.filter(f => !f.properties || !f.properties.hasOwnProperty(expectedProperty));
                
                if (missingPropertyFeatures.length > 0) {
                    console.warn(`Features missing expected property '${expectedProperty}' in ${layerId}:`, missingPropertyFeatures);
                } else {
                    console.log(`All features have the expected property '${expectedProperty}' in ${layerId}`);
                }

                // Log a sample feature to see its structure
                if (features.length > 0) {
                    console.log(`Sample feature from ${layerId}:`, features[0]);
                }
            } else {
                console.error(`Source not found for layer ${layerId}`);
            }
        }

        function checkStateFeatures(layerId, stateCode) {
            const source = map.getSource(layerId);
            if (source && source._data) {
                const data = source._data;
                if (data.features && Array.isArray(data.features)) {
                    const matchingFeatures = data.features.filter(feature => 
                        feature.properties && feature.properties.state === stateCode
                    );

                    if (matchingFeatures.length > 0) {
                        console.log(`Found ${matchingFeatures.length} features with state code '${stateCode}' in layer ${layerId}:`);
                        matchingFeatures.forEach((feature, index) => {
                            console.log(`Feature ${index + 1}:`, feature);
                        });
                    } else {
                        console.log(`No features found with state code '${stateCode}' in layer ${layerId}`);
                    }
                } else {
                    console.error(`Invalid GeoJSON structure for layer ${layerId}`);
                }
            } else {
                console.error(`Source not found or data not loaded for layer ${layerId}`);
            }
        }

        async function addGeoJsonLayer(layerId) {
            console.log('Adding GeoJSON layer:', layerId);
            const config = layerConfig[layerId];
            if (!config) {
                console.error('No configuration found for layer:', layerId);
                return;
            }
            console.log('Layer config:', config);
            
            // Remove existing layers
            if (map.getSource(currentLayerId)) {
                console.log('Removing existing layers for:', currentLayerId);
                map.removeLayer(currentLayerId + '-fill');
                map.removeLayer(currentLayerId + '-line');
                map.removeLayer(currentLayerId + '-hover-line');
                map.removeSource(currentLayerId);
            }

            // Load GeoJSON data
            try {
                const geoJsonData = await loadGeoJson(config.baseMap);
                
                // Add new source
                console.log('Adding new source:', layerId);
                map.addSource(layerId, {
                    type: 'geojson',
                    data: geoJsonData,
                    promoteId: config.idProperty
                });

                // Add fill layer
                console.log('Adding fill layer:', layerId + '-fill');
                const fillPaint = createFillPaint(layerId, config);
                console.log("Fill paint for layer", layerId, ":", fillPaint);
                map.addLayer({
                    id: layerId + '-fill',
                    type: 'fill',
                    source: layerId,
                    paint: {
                        'fill-color': fillPaint,
                        'fill-opacity': 0.7
                    }
                });

                // Add line layer
                console.log('Adding line layer:', layerId + '-line');
                map.addLayer({
                    id: layerId + '-line',
                    type: 'line',
                    source: layerId,
                    paint: {
                        'line-color': config.borderColor,
                        'line-width': config.borderWidth
                    }
                });

                // Add hover line layer
                console.log('Adding hover line layer:', layerId + '-hover-line');
                map.addLayer({
                    id: layerId + '-hover-line',
                    type: 'line',
                    source: layerId,
                    paint: {
                        'line-color': ['case', ['boolean', ['feature-state', 'hover'], false], COLOR_HOVER, config.borderColor],
                        'line-width': ['case', ['boolean', ['feature-state', 'hover'], false], 4, config.borderWidth],
                        'line-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0]
                    }
                });

                console.log('Moving layers to top');
                map.moveLayer('state-label')
                map.moveLayer('settlement-major-label')
                map.moveLayer('settlement-minor-label')
                // put hover line  above others
                map.moveLayer(layerId + '-hover-line');





                function showPinAndPop() {
                    const pin = document.querySelector('.pin');
                    const mapPop = document.querySelector('.map-pop');
                    
                    if (pin && mapPop) {
                        mapPop.style.left = `${pin.offsetLeft-30}px`;
                        mapPop.style.top = `${pin.offsetTop - mapPop.offsetHeight - 20}px`; 
                        
                        setTimeout(() => {
                            mapPop.classList.add('show'); 
                        }, 500);
                    }
                }

                showPinAndPop();

                

                map.on('mouseenter', layerId + '-fill',(e) => {
                    const mapPop = document.querySelector('.map-pop');
                    const pin = document.querySelector('.pin');
                    const pulse = document.querySelector('.pulse');

                    if (pin) {
                        pin.classList.add('hide');
                    }
                    
                    if (pulse) {
                        pulse.classList.add('hide');
                    }
                    
                    if (mapPop && !mapPop.classList.contains('hide')) {
                        mapPop.classList.add('hide');
                     
                    }

                });



                // mouse event for hovering
                map.on('mousemove', function (e) {
                    console.log("Entering mousemove event for layer:", layerId);

                    let features = map.queryRenderedFeatures(e.point, { layers: [layerId + '-fill'] });
                    console.log("features:", features);
                    if (features.length > 0) {
                        const feature = features[0];
                        const currentId = feature.properties[layerConfig[layerId].idProperty];
                        console.log("currentId:", currentId);
                        console.log("features:", features);
                        if (hoveredStateId !== currentId) {
                            if (hoveredStateId) {
                                map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: false });
                            }
                            hoveredStateId = currentId;
                            map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: true });
                        }

                        const popupContent = generateGenericPopupContent(feature, layerConfig[layerId], layerId);
                        popup.setLngLat(e.lngLat).setHTML(popupContent).addTo(map);
                        map.getCanvas().style.cursor = 'pointer';
                    } else {
                        if (hoveredStateId) {
                            map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: false });
                            hoveredStateId = null;
                        }
                        map.getCanvas().style.cursor = '';
                        popup.remove();
                    }
                });

                map.on('mouseleave', layerId + '-fill', function () {
                    if (hoveredStateId) {
                        map.setFeatureState({source: layerId, id: hoveredStateId}, { hover: false });
                        hoveredStateId = null;
                    }
                    map.getCanvas().style.cursor = '';
                    popup.remove();
                });

                // Update the current layer ID
                currentLayerId = layerId;
            } catch (error) {
                console.error('Failed to load GeoJSON data for layer:', layerId, error);
            }
        }

        document.querySelectorAll('.dropdown-content div').forEach(item => {
            item.addEventListener('click', function() {
                const selectedValue = this.getAttribute('data-value');
                const selectedText = this.textContent;
                document.querySelector('.dropbtn').textContent = selectedText; 
                console.log('Selected value:', selectedValue); 
            });
        });

        

        // Initial layer setup on map load
    map.on('load', function () {
        console.log('Map loaded');

        var dropdownOptions = document.querySelectorAll('#layer-dropdown div');
        var serverSelection = JSON.parse('{{ selection|default("house", true)|tojson|safe }}');
        var layerToAdd = 'house'; // Default layer
        var foundMatch = false;
        var buttonText = 'Choose Layer';

        dropdownOptions.forEach(function(option) {
            if (option.getAttribute('selectionValue') === serverSelection) {
                layerToAdd = option.getAttribute('selectionValue');
                option.classList.add('selected'); 
                foundMatch = true;
                buttonText = option.textContent;
            }
        });

        // If no match found, use the default 'house2'
        if (!foundMatch) {
            dropdownOptions.forEach(function(option) {
                if (option.getAttribute('data-value') === 'house2') {
                    option.classList.add('selected'); 
                    buttonText = option.textContent; 
                }
            });
        }

        console.log('About to call addGeoJsonLayer with:', layerToAdd);
        if (layerToAdd && layerToAdd in layerConfig) {
            addGeoJsonLayer(layerToAdd);
        } else {
            console.error('Invalid layer selected:', layerToAdd);
        }

        document.querySelector('.dropbtn').textContent = buttonText;

        const layers = map.getStyle().layers;
        layers.forEach((layer) => {
            const currentFilters = map.getFilter(layer.id);
            // if layer includes label or state filter for USA
            if (layer.id.includes('label') || layer.id.includes('state') || layer.id.includes('admin')) {
                if (currentFilters) {
                    map.setFilter(layer.id, ['all', currentFilters, ['==', ['get', 'iso_3166_1'], 'US']]);
                } else {
                    map.setFilter(layer.id, ['==', ['get', 'iso_3166_1'], 'US']);
                }
            }
        });

});

        document.getElementById('layer').addEventListener('change', function (e) {
            const value = e.target.value;
            if (value in layers) {
                addGeoJsonLayer(value);
            } else {
                Object.keys(layers).forEach(id => {
                    if (map.getLayer(id + '-fill')) {
                        map.removeLayer(id + '-fill');
                        map.removeLayer(id + '-line');
                        map.removeLayer(id + '-hover-line');  // Ensure hover line is also removed
                        map.removeSource(id);
                    }
                });
            }
        });


        

 

        // Add mouseenter event to hide map-pop when first entering map

       /* setTimeout(() => {
            document.querySelector('.map-pop').classList.add('hide');
        }, 25000);*/


                </script>


<script>
    document.addEventListener("DOMContentLoaded", function () {
    const dropdownButton = document.querySelector(".dropbtn");
    const dropdownContent = document.getElementById("layer-dropdown");

    dropdownButton?.addEventListener("click", function () {
        
        this.classList.toggle("active");
        const isActive = this.classList.contains("active");
        
        if (dropdownContent) {
            dropdownContent.style.display = isActive ? "block" : "none";
        }
    });
    
    dropdownContent.querySelectorAll("div").forEach(function (item) {
        item.addEventListener("click", function () {
            if (!dropdownButton || !dropdownContent) return;
            dropdownButton.textContent = this.textContent;

            dropdownButton.classList.remove("active");
            dropdownButton.classList.remove("active");
            dropdownContent.style.display = "none";
        });
    });
    
    window.addEventListener("click", function (event) {
        if (!dropdownButton || !dropdownContent) return;
        if (!dropdownButton.contains(event.target) && !dropdownContent.contains(event.target)) {
            dropdownButton.classList.remove("active");
            dropdownContent.style.display = "none";
        }
    });
});
</script>
            </div>
        </div>
    </div>

</body>
</div>




{% endblock %}
