{% extends "layout.html" %}
{% block main %}

<link rel="stylesheet" href="./static/detail.css">


<div class="detail-page">
    <body>
        

        

    <div class="row" height="100%">
        <div class="col" id="detail-left">


            <ul class="list-group" id="state-data-list">
                <!-- State data will be dynamically inserted here -->
            </ul>
        </div>

        <div class="col" id="detail-right">

        <div class="col" id="detail-right">
            <div class="map-overlay">
                <div class="map-overlay-inner">


                    <fieldset>
                        <label for="layer-dropdown">Currently viewing: </label>
                        <div class="dropdown">
                            <button class="dropbtn">Choose Layer</button>
                            <div class="dropdown-content" id="layer-dropdown">
                                <div data-value="ballot_vpm" selectionValue="democracy">Democracy ballot initiatives</div>
                                <div data-value="presidential" selectionValue="presidential">Presidential race</div>
                                <div data-value="senate" selectionValue="senate">Senate race</div>
                                <div data-value="house" selectionValue="house">House races</div>
                                <div data-value="state_house" selectionValue="state_house">State House races</div>
                                <div data-value="state_senate" selectionValue="state_senate">State Senate races</div>
                                <div data-value="ballot_others" selectionValue="others">State-level ballot issues</div>
                            </div>
                        </div>
                       
                      
                        <select id="layer" name="layer" style="display:none;">
                            <option value="ballot_vpm" selectionValue="democracy">Democracy ballot initiatives</option>
                            <option value="presidential" selectionValue="presidential">Presidential race</option>
                            <option value="senate" selectionValue="senate">Senate race</option>
                            <option value="house" selectionValue="house">House races</option>
                            <option value="state_house" selectionValue="state_house">State House races</div>
                            <option value="state_senate" selectionValue="state_senate">State Senate races</div>
                            <option value="ballot_others" selectionValue="others">State-level ballot issues</option>
                        </select>
                    </fieldset>
                </div>

                <div class="map-pop">
                    Mouseover for more info
                </div>
        
                <div class="col map-container-sm">
                    <div id="map"></div>  
                    <div id="loading-icon" class="loading-icon">Loading...</div>
                </div>

            </div>

            <div class='pin bounce'></div>
            <div class='pulse'></div>

            

        </div>

        
</div>
<script type="module">

// Add this near the top of your script, after other variable declarations
const geoJsonCache = {};
const loadingIcon = document.getElementById('loading-icon');

//convert dropdown to select
document.querySelectorAll('#layer-dropdown div').forEach(item => {
    item.addEventListener('click', function() {
        //get clicked data-value and selectionValue
        let selectedValue = this.getAttribute('data-value');
        let selectedText = this.getAttribute('selectionValue');

        let selectElement = document.getElementById('layer');
        selectElement.value = selectedValue;
        
        selectElement.dispatchEvent(new Event('change'));

        //update the url with the selected text
        const currentURL = new URL(window.location.href);
        currentURL.searchParams.set('selection', selectedText);

        //update the url without refreshing the page
        history.pushState(null, '', currentURL);
    });
});

//convert dropdown to select
document.querySelectorAll('#layer-dropdown div').forEach(item => {
    item.addEventListener('click', function() {
        //get clicked data-value and selectionValue
        let selectedValue = this.getAttribute('data-value');
        let selectedText = this.getAttribute('selectionValue');

        let selectElement = document.getElementById('layer');
        selectElement.value = selectedValue;
        
        selectElement.dispatchEvent(new Event('change'));

        //update the url with the selected text
        const currentURL = new URL(window.location.href);
        currentURL.searchParams.set('selection', selectedText);

        //update the url without refreshing the page
        history.pushState(null, '', currentURL);
    });
});

    const all_data = {{ all_data | tojson | safe }}
    // console.log("location", {{ location | tojson | safe }})
    const state_to_number = {{ state_to_number | tojson | safe }};
    // Create a master dictionary to hold all state data
    let masterStateData = {};
    const location = {{ location | tojson | safe }};
    if (typeof location === 'string') {
        masterStateData[location] = {};
    }

    // Function to add data to the master dictionary
    function addToMasterData(dataList, category) {
        //console.log('Adding data to master data:', dataList, category);
        dataList.forEach(item => {
            const state = typeof item.state_name === 'string' ? item.state_name.trim() : 'Unknown';
            if (!masterStateData[state]) {
                masterStateData[state] = {};
            }
            if (!masterStateData[state][category]) {
                masterStateData[state][category] = [];
            }
            masterStateData[state][category].push(item);
        });
    }

    // Process each data list
    //console.log("pres_list", {{ pres_list | tojson | safe }})
    addToMasterData({{ pres_list | tojson | safe }}, 'presidential');
    addToMasterData({{ senate_list | tojson | safe }}, 'senate');
    addToMasterData({{ house_list | tojson | safe }}, 'house');
    addToMasterData({{ state_house_list | tojson | safe }}, 'state_house');
    addToMasterData({{ state_senate_list | tojson | safe }}, 'state_senate');
    addToMasterData({{ governor_list | tojson | safe }}, 'governor');
    addToMasterData({{ dem_ballot_list | tojson | safe }}, 'democracy_repair_ballots');
    addToMasterData({{ state_level_list | tojson | safe }}, 'state_level_ballots');

    // Define the list of required categories
    const requiredCategories = [
        'presidential', 'senate', 'house', 'state_house', 'state_senate',
        'governor', 'democracy_repair_ballots', 'state_level_ballots'
    ];

    // Ensure each state has all required categories
    Object.keys(masterStateData).forEach(state => {
        requiredCategories.forEach(category => {
            masterStateData[state][category] = masterStateData[state][category] || [];
        });
    });

    const ballotData = {{ ballot_initiatives | tojson | safe }};
    Object.keys(masterStateData).forEach(state => {
        Object.keys(masterStateData[state]).forEach(category => {
            if (category.includes('ballot')) {
                masterStateData[state][category].forEach(item => {
                    const matchingBallot = ballotData.find(ballot => 
                        ballot.state_name === state && 
                        ballot.election_name === item.election_name
                    );
                    if (matchingBallot) {
                        // Merge ballot data with existing item
                        Object.assign(item, matchingBallot);
                    } else {
                        console.warn(`No matching ballot found for ${state} - ${item.election_name}`);
                    }
                });
            }
        });
    });

    console.log("masterStateData", masterStateData)
    function createLearnMoreButton(item) {

        if (item.eid && item.candidate_ids && item.candidate_ids.length > 0) {
            return `
                <a href="/get-involved?candidates=${item.candidate_ids}&election=${item.eid}" 
                   class="btn btn-primary btn-info custom-btn">
                    Learn More
                </a>
            `;
        } else {
            return `
                <button class="btn btn-primary btn-info custom-btn" disabled>
                    More Info Soon
                </button>
            `;
        }
    }

    
    function createCategoryList(categoryData, categoryTitle) {
        // if (!categoryData || categoryData.length === 0) return '';
        
        let tableRows = '';
        let description = '';
        /*let rowsNonEmpty = (categoryData && categoryData.length > 0)*/
        let rowsNonEmpty = Array.isArray(categoryData) && categoryData.some(item => 
            (item.candidate_names && item.candidate_names.length > 0) || 
            (item['name of ballot'] && item['name of ballot'].trim() !== '') ||
            (item.election_name && item.election_name.trim() !== '')
        );
        let hasElectedOffices = false;

        switch (categoryTitle) {
            case 'Democracy':
                if (rowsNonEmpty) {
                    description = `<p class="category-description-fixed">These initiatives make long-term changes to the practice of democracy in this state.</p>`;
                    categoryData.sort((a, b) => (a.election_name || '').localeCompare(b.election_name || ''));
                    tableRows = categoryData.map(item => `
                        <tr>
                            <td class="text-wrap" colspan="2">${item.candidate_names || item['name of ballot'] || item.election_name}</td>
                            <td>${createLearnMoreButton(item)}</td>
                        </tr>
                    `).join('');
                } else {
                    tableRows = `<tr><td colspan="3">No such ballot initiatives exist in this state.</td></tr>`;
                }
                break;

            case 'Elected Offices':
                // <tr class="subcategory-header"><td colspan="3">President</td></tr>
                if (categoryData.president && categoryData.president.voter_power > 20) {
                    hasElectedOffices = true;
                  
                    const item = categoryData.president;
                    const candidate_ids = item.candidate_ids;
                    const election = `${item.state_name} ${item.election_name}`;
                    const election_id = item.eid;


                    tableRows +=`
                        <tr>
                            <td>President</td>
                            <td>${Math.round(categoryData.president.voter_power)}</td>
                            <td>${createLearnMoreButton(item)}</td>
                        </tr>
                    `;
                }
                else {
                    tableRows += `<tr><td colspan="3" class="missing">This presidential race does not have high voter power.</td></tr>`;
                } 
                if (categoryData.senate && categoryData.senate.voter_power > 20) {
                    hasElectedOffices = true;
                    const item = categoryData.senate;

                    tableRows += `
                        <tr>
                            <td>Senate</td>
                            <td>${Math.round(categoryData.senate.voter_power)}</td>
                            <td>${createLearnMoreButton(item)}</td>
                        </tr>
                    `;
                }
                else {
                    tableRows += `<tr><td colspan="3" class="missing">This U.S. Senate race does not have high voter power.</td></tr>`;
                } 
                const highPowerHouseDistricts = categoryData.house.filter(item => item.voter_power > 20);
                
                if (highPowerHouseDistricts && highPowerHouseDistricts.length > 0) {
                    hasElectedOffices = true;
                    tableRows += `<tr class="subcategory-header"><td colspan="3">U.S. House</td></tr>`;
                    tableRows += highPowerHouseDistricts.map(item => `
                        <tr>
                            <td>${item.election_name.replace(/^Congressional\s*/, '').trim() || 'N/A'}</td>
                            <td>${Math.round(item.voter_power)}</td>
                            <td>${createLearnMoreButton(item)}</td>
                        </tr>
                    `).join('');
                }
                else {
                    tableRows += `<tr><td colspan="3" class="missing">No U.S. House races have high voter power.</td></tr>`;
                }                
                const highPowerStateSenateDistricts = categoryData.state_senate.filter(item => item.voter_power > 20);
                
                if (highPowerStateSenateDistricts && highPowerStateSenateDistricts.length > 0) {
                    
                    tableRows += `<tr class="subcategory-header"><td colspan="3">State Senate</td></tr>`;
                    tableRows += highPowerStateSenateDistricts.map(item => `
                        <tr>
                            <td>${item.election_name.replace(/^State Senate\s*/, '').trim() || 'N/A'}</td>
                            <td>${Math.round(item.voter_power)}</td>
                            <td>${createLearnMoreButton(item)}</td>
                        </tr>
                    `).join('');
                }
                else {
                    tableRows += `<tr><td colspan="3" class="missing">No state senate races have high voter power.</td></tr>`;
                }
                
                const highPowerStateHouseDistricts = categoryData.state_house.filter(item => item.voter_power > 20);
                
                if (highPowerStateHouseDistricts && highPowerStateHouseDistricts.length > 0) {
                    hasElectedOffices = true;
                    tableRows += `<tr class="subcategory-header"><td colspan="3">State House</td></tr>`;
                    tableRows += highPowerStateHouseDistricts.map(item => `
                        <tr>
                            <td>${item.election_name.replace(/^State House\s*/, '').trim() || 'N/A'}</td>
                            <td>${Math.round(item.voter_power)}</td>
                            <td>${createLearnMoreButton(item)}</td>
                        </tr>
                    `).join('');
                }
                else {
                    tableRows += `<tr><td colspan="3" class="missing">No state house races have high voter power.</td></tr>`;
                }                
                break;

            case 'Other ballot initiatives':
                console.log("categoryData", categoryData)
                description = '' 
                if (rowsNonEmpty) {
                    categoryData.sort((a, b) => {
                        if (a.race_type !== b.race_type) return b.race_type.localeCompare(a.race_type);
                        return a.election_name.localeCompare(b.election_name);
                    });
                    tableRows = categoryData.map(item => `
                        <tr>
                            <td class="text-wrap" colspan="2">
                                ${item.candidate_names || item['name of ballot'] || item.election_name}
                            </td>
                            <td>${createLearnMoreButton(item)}</td>
                        </tr>
                    `).join('');
                } else {
                    tableRows += `<tr><td colspan="3" class="missing">No ballot initiatives in this state.</td></tr>`;

                }
                break;
            }
        // Determine column headers based on category
        let columnHeaders = '';
        if (categoryTitle === 'Democracy' || categoryTitle === 'Other ballot initiatives') {
            if (rowsNonEmpty) {
                columnHeaders = `
                    <tr>
                        <th colspan="2">Initiative</th>
                        <th></th>
                    </tr>
                `;
            }
        } else {
            if (hasElectedOffices) {
                    description = `<p class="category-description-fixed">Elected offices where the <a href="/voter-power" target="_blank">power of individual voters</a> is high:</p>`;
            columnHeaders = `
                <tr>
                    <th>Office</th>
                    <th>Voter Power <span class="vote-info">The power of one more vote (max = 100)</span></th>
                    <th></th>
                </tr>
            `;
        } 
    }

        return `
            <table class="table">
                <thead>
                    <tr class="category-title">
                        <th colspan="3">${categoryTitle}</th>
                    </tr>
                    <tr class="category-description">
                        <td colspan="3">${description}</td>
                    </tr>
                    ${columnHeaders}
                </thead>
                <tbody>
                    ${tableRows}
                </tbody>
            </table>
        `;
    }

   

    function populateStateList() {
        const stateDataList = document.getElementById('state-data-list');
        stateDataList.innerHTML = ''; // Clear existing content

        for (const state in masterStateData) {
            const stateData = masterStateData[state];
            let stateHtml = `
            
                <div class="state-section" id="state-${state.toLowerCase().replace(/\s+/g, '-')}">
                <h3>${state}</h3>
            `;

            stateHtml += createCategoryList(stateData.democracy_repair_ballots, 'Democracy', state);
            stateHtml += createCategoryList({
                president: stateData.presidential?.[0] ?? [],
                senate: stateData.senate?.[0] ?? [],
                house: stateData.house || [],
                state_senate: stateData.state_senate || [],
                state_house: stateData.state_house || [],
            }, 'Elected Offices');

            console.log("stateData.state_level_ballots", stateData.state_level_ballots)
            stateHtml += createCategoryList(stateData.state_level_ballots , 'Other ballot initiatives', state);

            stateHtml += `</div>`;
            stateDataList.innerHTML += stateHtml;
        }
    }

    // Call the function to populate the list
    populateStateList();
        

                    mapboxgl.accessToken = '{{ mapbox_key }}';
                    const map = new mapboxgl.Map({
                        container: 'map',
                        style: 'mapbox://styles/mikeklein1/clxkrmlob01s801qkb96q6c00/draft',
                        center: ['{{ long }}', '{{ lat }}'],  
                        zoom: 5, 
                        minZoom: 3,
                        maxZoom: 7,
                        dragPan: true,  // Disable panning
                        keyboard: true,
                        dragRotate: false,  // Disable rotation
                        keyboard: false,  // Disable keyboard navigation
                        doubleClickZoom: true,  // Disable double click zoom
                        touchZoomRotate: false, // Disable touch zoom and rotate
                        projection: 'mercator'
                    });

                    class ZoomControl {
                        onAdd(map) {
                        console.log('ZoomControl added');
                        this._map = map;
                        this._container = document.createElement('div');
                        this._container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
                        this._container.style.backgroundColor = 'white';
                        this._container.style.border = '1px solid #ccc';
                        this._container.style.borderRadius = '4px';
                        this._container.style.zIndex = '1000';  
                        
                        const zoomInButton = this._createButton('+', () => {
                            map.zoomIn();
                        });
                        
                        const zoomOutButton = this._createButton('-', () => {
                            map.zoomOut();
                        });

                        this._container.appendChild(zoomInButton);
                        this._container.appendChild(zoomOutButton);

                        console.log('Buttons created and added to container');
                        return this._container;
                    }
                    onRemove() {
                        console.log('ZoomControl removed');
                        this._container.parentNode.removeChild(this._container);
                        this._map = undefined;
                    }

                    _createButton(text, onClick) {
                        console.log(`Creating button: ${text}`);
                        const button = document.createElement('button');
                        button.className = 'mapboxgl-ctrl-icon';
                        button.type = 'button';
                        button.style.width = '30px';
                        button.style.height = '30px';
                        button.style.fontSize = '20px';
                        button.style.fontWeight = 'bold';
                        button.style.border = 'none';
                        button.style.display = 'block';
                        button.style.cursor = 'pointer';
                        button.textContent = text;
                        button.onclick = onClick;
                        return button;
                    }
                }

                
        const layers = {
            
            presidential: 'static/data/calculated_files/geojsons/president.geojson',
            senate: 'static/data/calculated_files/geojsons/senate.geojson',
            house: 'static/data/geojson_imports/geojson_final/house.geojson',
            ballot_abort: 'static/data/geojson_imports/geojson_final/ballot_abort.geojson',
           // ballot_abort:'static/data/calculated_files/geojsons/reprights.geojson',
            ballot_vpm: 'static/data/geojson_imports/geojson_final/ballot_VPM.geojson',
            ballot_others: 'static/data/geojson_imports/geojson_final/ballot_other.geojson',
            state_senate:'static/data/geojson_imports/geojson_final/state_leg_upper.geojson',
            state_house:'static/data/geojson_imports/geojson_final/state_leg_lower.geojson'
        };

       
        const senateList = {{senate_list | tojson}};



        let hoveredStateId = null; // This will hold the ID of the feature under the mouse.
        let currentLayerId = null; // Track the current layer


        const popup = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false,
            offset: [0, -15], // Add a slight vertical offset
            className: 'custom-popup'
        });
        

        async function addGeoJsonLayer(layerId) {
            console.log("Adding layer:", layerId);
            console.log("currentLayerId:", currentLayerId);
            
            // Show loading icon
            loadingIcon.style.display = 'flex';

            try {
                // Remove existing layers and source
                if (map.getSource(currentLayerId)) {
                    map.removeLayer(currentLayerId + '-fill');
                    map.removeLayer(currentLayerId + '-line');
                    map.removeLayer(currentLayerId + '-hover-line');
                    map.removeSource(currentLayerId);
                }

                currentLayerId = layerId;
                
                // Check if the processed GeoJSON is in the cache
                if (!geoJsonCache[layerId]) {
                    console.log(`Loading GeoJSON for ${layerId}`);
                    const response = await fetch(layers[layerId]);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    // Process the GeoJSON data and store it in the cache
                    geoJsonCache[layerId] = preprocessGeoJSON(data, layerId);
                }

                map.addSource(layerId, {
                    type: 'geojson',
                    data: geoJsonCache[layerId],
                    promoteId: layerId === 'house' ? 'GEOIDFQ' : 'STATEFP'
                });
                console.log(`Added source for ${layerId}. Feature count: ${geoJsonCache[layerId].features.length}`);

                map.addLayer({
                    id: layerId + '-fill',
                    type: 'fill',
                    source: layerId,
                    paint: {
                        'fill-color': [
                            'case',
                            ['==', ['literal', layerId], 'ballot_vpm'], [
                                'interpolate',
                                ['linear'],
                                ['get', 'initiative_count'],
                                0, '#D3D3D3',
                                1, '#E8E8FF',
                                5, '#9494FF',
                                10, '#6262FF'
                            ],
                            ['==', ['literal', layerId], 'ballot_others'], [
                                'interpolate',
                                ['linear'],
                                ['get', 'initiative_count'],
                                0, '#D3D3D3',
                                1, '#FFE8E8',
                                5, '#FF9494',
                                10, '#FF6262'
                            ],
                            // For all other layers, use voter_power
                            [
                                'interpolate',
                                ['linear'],
                                ['get', 'voter_power'],
                                0, '#D3D3D3',
                                1, ['match', 
                                    ['literal', layerId],
                                    'presidential', '#feedde',
                                    'senate', '#fff5e0',
                                    'house', '#F6FAFC',
                                    'state_senate', '#ffffcc',
                                    'state_house', '#f1eef6',
                                    '#D3D3D3'
                                ],
                                100, ['match', 
                                    ['literal', layerId],
                                    'presidential', '#D7301F',
                                    'senate', '#fec548',
                                    'house', '#B4CDE3',
                                    'state_senate', '#225ea8',
                                    'state_house', '#ce1256',
                                    '#D3D3D3'
                                ]
                            ]
                        ],
                        'fill-opacity': 1
                    }
                }, 'state-label');

                // Log the paint property to verify
                //console.log(`Layer ${layerId} paint property:`, map.getPaintProperty(layerId + '-fill', 'fill-color'));

                // line layer should be black as default
                map.addLayer({
                    id: layerId + '-line',
                    type: 'line',
                    source: layerId,
                    layout: {},
                    paint: {
                        'line-color': '#808080',
                        'line-width': 0.7,
                        'line-opacity': 0.8
                    }
                });

                // add line layer that highlights when hovering 
                map.addLayer({
                    id: layerId + '-hover-line',
                    type: 'line',
                    source: layerId,
                    layout: {},
                    paint: {
                        'line-color': ['case', ['boolean', ['feature-state', 'hover'], false], '#ffffff', '#000'],
                        'line-width': ['case', ['boolean', ['feature-state', 'hover'], false], 4, 2],
                        'line-opacity': ['case', ['boolean', ['feature-state', 'hover'], false], 1, 0]
                    }
                });

               // map.moveLayer('state-label')
                //map.moveLayer('settlement-major-label')
                //map.moveLayer('settlement-minor-label')
                // put hover line  above others
                map.moveLayer(layerId + '-hover-line');

                // Add event listeners after the layer is added
                map.on('mouseenter', currentLayerId + '-fill',(e) => {
                    const mapPop = document.querySelector('.map-pop');
                    const pin = document.querySelector('.pin');
                    const pulse = document.querySelector('.pulse');

                    if (pin) {
                        pin.classList.add('hide');
                    }
                    
                    if (pulse) {
                        pulse.classList.add('hide');
                    }
                    
                    if (mapPop && !mapPop.classList.contains('hide')) {
                        mapPop.classList.add('hide');
                     
                    }      
                });

                map.on('mouseleave', currentLayerId + '-fill', function() {
                    if (hoveredStateId) {
                        map.setFeatureState({source: currentLayerId, id: hoveredStateId}, { hover: false });
                        hoveredStateId = null;
                    }
                    map.getCanvas().style.cursor = '';
                    popup.remove();
                });

                // Hide loading icon when done
                loadingIcon.style.display = 'none';
            } catch (error) {
                console.error('Error adding GeoJSON layer:', error);
                console.error('Current layer ID:', currentLayerId);
                console.error('Attempted new layer ID:', layerId);
                loadingIcon.style.display = 'none';
            }
        }

            function showPinAndPop() {
                const pin = document.querySelector('.pin');
                const mapPop = document.querySelector('.map-pop');
                
                if (pin && mapPop) {
                    mapPop.style.left = `${pin.offsetLeft-30}px`;
                    mapPop.style.top = `${pin.offsetTop - mapPop.offsetHeight - 20}px`; 
                    
                    setTimeout(() => {
                        mapPop.classList.add('show'); 
                    }, 500);
                }
            }

            showPinAndPop();

            





            // Define popup content generation functions for each layer type
const popupContentGenerators = {
    gubernatorial: (props) => `
        <div class="custom-popup">
            <div class="popup-row"><div class="popup-label"><strong>State:</strong></div><span class="popup-value">${props.name}</span></div>
            ${props.candidateNames ? `<div class="popup-row"><div class="popup-label"><strong>Candidates:</strong></div><span class="popup-value">${props.candidateNames}</span></div>` : ''}
            <div class="popup-row"><div class="popup-label"><strong>Voter Power:</strong></div><span class="popup-value">${props.voterPower}</span></div>
        </div>
    `,
    presidential: (props) => `
        <div class="custom-popup">
            <div class="popup-row"><div class="popup-label"><strong>State:</strong></div><span class="popup-value">${props.name}</span></div>
            ${props.candidateNames ? `<div class="popup-row"><div class="popup-label"><strong>Candidates:</strong></div><span class="popup-value">${props.candidateNames}</span></div>` : ''}
            <div class="popup-row"><div class="popup-label"><strong>Voter Power:</strong></div><span class="popup-value">${props.voterPower}</span></div>
        </div>
    `,
    state_leg: (props) => `
        <div class="custom-popup">
            <div class="popup-row"><div class="popup-label"><strong>District name:</strong></div><span class="popup-value">${props.name}</span></div>
            ${props.candidateNames ? `<div class="popup-row"><div class="popup-label"><strong>Candidates:</strong></div><span class="popup-value">${props.candidateNames}</span></div>` : ''}
            <div class="popup-row"><div class="popup-label"><strong>Voter Power:</strong></div><span class="popup-value">${props.voterPower}</span></div>
        </div>
    `,
    ballot: (props) => `
    <div class="custom-popup">
        <div class="popup-header">
            <strong>${props.statename}</strong>
        </div>
        <div class="popup-content">
            <div style="border-bottom: 1px solid #ccc; margin-bottom: 5px;"></div>
            <div><strong>Number of initiatives: ${props.initiativeCount}</strong></div>
            <div style="font-size: 0.9em; color: #666;">See table for more information.</div>
        </div>
    </div>
    `,
    default: (props) => `
        <div class="custom-popup">
            <div class="popup-row"><div class="popup-label"><strong>${props.layerId === 'house' ? 'District' : 'State'}:</strong></div><span class="popup-value">${props.name}</span></div>
            ${props.candidateNames ? `<div class="popup-row"><div class="popup-label"><strong>Candidates:</strong></div><span class="popup-value">${props.candidateNames}</span></div>` : ''}
            <div class="popup-row"><div class="popup-label"><strong>Voter Power:</strong></div><span class="popup-value">${props.voterPower === undefined ? 'no competitive race' : props.voterPower}</span></div>
        </div>
    `
};

// Mapping of layer IDs to popup content generator functions
const layerToPopupGenerator = {
    gubernatorial: popupContentGenerators.gubernatorial,
    presidential: popupContentGenerators.presidential,
    state_leg_up: popupContentGenerators.state_leg,
    state_leg_low: popupContentGenerators.state_leg,
    ballot_abort: popupContentGenerators.ballot,
    ballot_vpm: popupContentGenerators.ballot,
    ballot_others: popupContentGenerators.ballot
};

// After the all_data declaration
let indexedData = {};
if (Array.isArray(all_data) && all_data.length > 0) {
    indexedData = all_data.reduce((acc, row) => {
        let key = row.state || row.STATEFP;
        if (['presidential', 'governor', 'senate'].includes(row.race_type.toLowerCase())) {
            key = `${row.state}-${row.race_type.toLowerCase()}`;
        } else if (row.race_type === 'House') {
            if (row.congress) {
                const district = row.congress.toString().padStart(2, '0');
                key += `-house-${district}`;
            } else {
                console.warn("Congress property not found in row:", row);
                key += 'house-unknown';
            }
        } else if (row.race_type === 'Democracy Repair') {
            key += `-ballot_vpm`;
        } else if (['Direct Democracy', 'Reproductive Rights', 'Civil Liberties'].includes(row.race_type)) {
            key += `-ballot_others`;
        } else if (row.race_type === 'State Leg (Lower)') {
            key += `-state_house-${row.s_lower}`;
        } else if (row.race_type === 'State Leg (Upper)') {
            key += `-state_senate-${row.s_upper}`;
        } else {
            // Handle other race types if needed
            return acc;
        }

        if (!acc[key]) acc[key] = [];
        acc[key].push(row);
        return acc;
    }, {});
} else {
    console.warn('all_data is not properly defined or is empty');
}
// console.log("indexedData", indexedData)
function findMatchingRows(feature, layerId) {
    if (!indexedData) return [];
    
    const state = (feature.properties.state || feature.properties.STATEFP || '').toString().padStart(2, '0');
    let key = `${state}-`;
    
    switch (layerId) {
        case 'ballot_abort':
        case 'ballot_others':
            key += 'ballot_others';
            break;
        case 'ballot_vpm':
            key += 'ballot_vpm';
            break;
        case 'presidential':
            key += 'presidential';
            break;
        case 'senate':
            key += 'senate';
            break;
        case 'house':
            if (feature.properties.congress) {
                const district = feature.properties.congress.toString().padStart(2, '0');
                key += `house-${district}`;
            } else {
                console.warn("Congress property not found in feature:", feature);
                return []; // Return an empty array if no congress property is found
            }
            break;
        case 'state_house':
            if (feature.properties.s_lower) {
                const district = feature.properties.s_lower.toString().padStart(3, '0');
                key += `state_house-${district}`;
            } else {
                console.warn("State House property not found in feature:", feature);
                return []; // Return an empty array if no state house property is found
            }
            break;
        case 'state_senate':
            if (feature.properties.s_upper) {
                const district = feature.properties.s_upper.toString().padStart(3, '0');
                key += `state_senate-${district}`;
            } else {
                console.warn("State Senate property not found in feature:", feature);
                return []; // Return an empty array if no state senate property is found
            }
            break;
        case 'gubernatorial':
            key += 'governor';
            break;
        default:
            console.warn(`Unhandled layerId: ${layerId}`);
            return [];
    }
    
    //console.log("Searching for key:", key);
    const result = indexedData[key] || [];
    //console.log("result", result)
    return result;
}
function preprocessGeoJSON(geoJSON, layerId) {
    //console.log(`Preprocessing GeoJSON for layer: ${layerId}`);
    //console.log(`Initial feature count: ${geoJSON.features.length}`);
    
    geoJSON.features.forEach((feature, index) => {
        const matchingRows = findMatchingRows(feature, layerId);
        
        if (layerId === 'ballot_vpm' || layerId === 'ballot_others') {
            feature.properties.initiative_count = matchingRows.length;
            //console.log(`Feature ${index}: Set initiative_count to ${feature.properties.initiative_count}`);
        } else {
            feature.properties.voter_power = matchingRows.length > 0
                ? Math.max(...matchingRows
                    .map(row => parseFloat(row.voter_power))
                    .filter(power => !isNaN(power) && power !== null)) || 0
                : 0;
            //console.log(`Feature ${index}: Set voter_power to ${feature.properties.voter_power}`);
        }
    });
    
      console.log(`Preprocessing complete. Final feature count: ${geoJSON.features.length}`);
    return geoJSON;
}

// Modify the existing findMatchingRows function or add a new function
function getFeatureValue(feature, layerId) {
    const matchingRows = findMatchingRows(feature, layerId);
    
    if (layerId === 'ballot_vpm' || layerId === 'ballot_others') {
        return matchingRows.length; // Return count of initiatives
    } else {
        // For other layers, return max voter power
        return Math.max(...matchingRows
            .map(row => parseFloat(row.voter_power))
            .filter(power => !isNaN(power) && power !== null)
        ) || 0;
    }
}

function getColor(value, layerId) {
    //console.log(`Getting color for value: ${value}, layerId: ${layerId}`);
    if (value === 0 || value === null || isNaN(value)) return '#D3D3D3';
    
    const colorScales = {
        presidential: ['#feedde', '#fdbe85', '#EF6548', '#D7301F'],
        senate: ['#fff5e0', '#ffebb5', '#ffe082', '#fec548'],
        house: ['#F6FAFC', '#E3EEF5', '#D1E2ED', '#B4CDE3'],
        state_senate: ['#ffffcc', '#a1dab4', '#41b6c4', '#225ea8'],
        state_house: ['#f1eef6', '#d7b5d8', '#df65b0', '#ce1256'],
        ballot_vpm: ['#E8E8FF', '#C6C6FF', '#9494FF', '#6262FF'],
        ballot_others: ['#FFE8E8', '#FFC6C6', '#FF9494', '#FF6262']
    };
    
    const scale = colorScales[layerId] || colorScales.house;
    
    let t;
    if (layerId === 'ballot_vpm' || layerId === 'ballot_others') {
        // For ballot initiatives, scale based on count (assuming max of 10 for example)
        t = Math.min(value / 10, 1);
    } else {
        // For voter power, scale as before
        t = Math.min(value / 100, 1);
    }
    
    const index = Math.floor(t * (scale.length - 1));
    return scale[index];
}

// Mouse event for hovering
map.on('mousemove', function (e) {

    let features = map.queryRenderedFeatures(e.point, { layers: [currentLayerId + '-fill'] });

    //  console.log("currentLayerId", currentLayerId)

    // console.log("layerId", layerId)
    // console.log("INside mousemove", features)
    if (features.length > 0) {
        const feature = features[0];
        const currentId = feature.layer.source;

        if (hoveredStateId !== currentId) {
            if (hoveredStateId) {
                map.setFeatureState({source: currentLayerId, id: hoveredStateId}, { hover: false });
            }
            hoveredStateId = currentId;
            map.setFeatureState({source: currentLayerId, id: hoveredStateId}, { hover: true });
        }

        const matchingRows = findMatchingRows(feature, currentLayerId) || [];

        let props = {
            matchingRows: matchingRows,
            name: matchingRows.length > 0 ? matchingRows[0].state_name : (feature.properties['NAME'] || feature.properties['NAMELSAD']),
            voterPower: matchingRows.length > 0 
                ? Math.max(...matchingRows
                    .map(row => parseFloat(row.voter_power))
                    .filter(power => !isNaN(power) && power !== null)
                ) || 'no race'
                : 'no race',
            ballotname: feature.properties['name.of.ballot'] || '',
            statename: feature.properties['state_name'] || getStateNameFromNumber(feature.properties['state']),
            description: feature.properties['description'] || 'No description available',
            layerId: currentLayerId,
            initiativeCount: matchingRows.length

                        };
                        // Safely set candidateNames with null checks
                        props.candidateNames = Array.isArray(props.matchingRows) 
                            ? props.matchingRows
                                .map(row => row && row.candidate_names)
                                .filter(Boolean)
                                    .join(', ')
                            : '';

                        //console.log("Props", props)
                        //console.log("feature.properties", feature.properties)


        const popupGenerator = layerToPopupGenerator[currentLayerId] || popupContentGenerators.default;
        const popupContent = popupGenerator(props);

        popup.setLngLat(e.lngLat).setHTML(popupContent).addTo(map);
        map.getCanvas().style.cursor = 'crosshair';
    } else {
        resetHoverState();
    }
});

map.on('mouseleave', currentLayerId + '-fill', resetHoverState);

function resetHoverState() {
    if (hoveredStateId) {
        map.setFeatureState({source: currentLayerId, id: hoveredStateId}, { hover: false });
        hoveredStateId = null;
    }
    map.getCanvas().style.cursor = '';
    popup.remove();
}

function getStateNameFromNumber(stateNumber) {
    if (stateNumber) {
        return Object.keys(state_to_number).find(key => state_to_number[key] === stateNumber) || 'Not available';
    }
    return 'Not available';
}



        document.querySelectorAll('.dropdown-content div').forEach(item => {
            item.addEventListener('click', function() {
                const selectedValue = this.getAttribute('data-value');
                const selectedText = this.textContent;
                document.querySelector('.dropbtn').textContent = selectedText; 
                 
            });
        });

            

            // Initial layer setup on map load
        map.on('load', async function () {
            try {
                // Show loading icon
                loadingIcon.style.display = 'flex';

                map.addControl(new ZoomControl(), 'bottom-left');

                var dropdownOptions = document.querySelectorAll('#layer-dropdown div');
                var serverSelection = JSON.parse('{{ selection|default("house", true)|tojson|safe }}');
                var layerToAdd = 'house'; // Default layer
               // var dropdown = document.getElementById('layer');
                var foundMatch = false;
                var buttonText = 'Choose Layer';

            
                // Check if serverSelection corresponds to a valid layer option
              /*  for (var i = 0; i < dropdown.options.length; i++) {
                    var option = dropdown.options[i];
                    if (option.getAttribute('selectionValue') === serverSelection) {
                        layerToAdd = option.value;
                        option.selected = true;
                        foundMatch = true;
                        break;
                    }
                }*/

                dropdownOptions.forEach(function(option) {
                    if (option.getAttribute('selectionValue') === serverSelection) {
                        layerToAdd = option.getAttribute('data-value');
                        option.classList.add('selected'); 
                            foundMatch = true;
                            buttonText = option.textContent; 
                        }
                    });

                // If no match found, look for house or house option
                if (!foundMatch) {
                    dropdownOptions.forEach(function(option) {
                        if (option.getAttribute('data-value') === 'house' || option.getAttribute('selectionValue') === 'house') {
                            option.classList.add('selected'); 
                            layerToAdd = 'house';
                            buttonText = option.textContent; 
                        }
                    });
                }

              /* if (!foundMatch) {
                    for (var i = 0; i < dropdown.options.length; i++) {
                        var option = dropdown.options[i];
                        if (option.value === 'house' || option.getAttribute('selectionValue') === 'house') {
                            option.selected = true;
                            layerToAdd = 'house';
                            break;
                        }
                    }
                }*/

                var selectElement = document.getElementById('layer');
                selectElement.value = layerToAdd;
                selectElement.dispatchEvent(new Event('change', { bubbles: true }));

                document.querySelector('.dropbtn').textContent = buttonText;


                //trigger event for change in layer and attach the corrrect e.target.value

               /*     console.log('About to trigger change event with value:', layerToAdd);
                    document.getElementById('layer').value = layerToAdd;
                    document.getElementById('layer').dispatchEvent(new Event('change', {bubbles: true}));*/

                   


                //addGeoJsonLayer(layerToAdd);
                //console.log(`Selected = ${serverSelection} and layer = ${layerToAdd}`);
                const layers = map.getStyle().layers;
                layers.forEach((layer) => {
                    const currentFilters = map.getFilter(layer.id);
                    // if layer includes label or state filter for USA
                    if (layer.id.includes('label') || layer.id.includes('state') || layer.id.includes('admin')) {
                        if (currentFilters) {
                            map.setFilter(layer.id, ['all', currentFilters, ['==', ['get', 'iso_3166_1'], 'US']]);
                        } else {
                            map.setFilter(layer.id, ['==', ['get', 'iso_3166_1'], 'US']);
                        }
                    }
                });

                // Hide loading icon when done
                loadingIcon.style.display = 'none';
            } catch (error) {
                console.error('Error during initial map setup:', error);
                // Hide loading icon if there's an error
                loadingIcon.style.display = 'none';
            }
        });

            document.getElementById('layer').addEventListener('change', function (e) {
                const value = e.target.value;
                if (value in layers) {
                    currentLayerId = value;
                    addGeoJsonLayer(value);
                } else {
                    console.log("Invalid layer value:", value);
                }
            });


document.addEventListener("DOMContentLoaded", function () {
    const dropdownButton = document.querySelector(".dropbtn");
    const dropdownContent = document.getElementById("layer-dropdown");
    
    dropdownButton.addEventListener("click", function () {
        this.classList.toggle("active");
        const isActive = this.classList.contains("active");
        
        if (dropdownContent) {
            dropdownContent.style.display = isActive ? "block" : "none";
        }
    });
    
    dropdownContent.querySelectorAll("div").forEach(function (item) {
        item.addEventListener("click", function () {
            dropdownButton.textContent = this.textContent;
            dropdownButton.classList.remove("active");
            dropdownContent.style.display = "none";
        });
    });
    
    window.addEventListener("click", function (event) {
        if (dropdownButton && !dropdownButton.contains(event.target) 
            && !dropdownContent.contains(event.target) && dropdownContent && !dropdownContent.contains(event.target)) {
                dropdownButton.classList.remove("active");
                dropdownContent.style.display = "none";
            }
        });
    
   
});
</script>
            </div>
        </div>
    </div>

</body>
</div>




{% endblock %}
